"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "generateFileData", {
    enumerable: true,
    get: function() {
        return generateFileData;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _mkdirp = /*#__PURE__*/ _interop_require_default(require("mkdirp"));
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _errors = require("../errors");
const _FileRetrievalError = /*#__PURE__*/ _interop_require_default(require("../errors/FileRetrievalError"));
const _canResizeImage = /*#__PURE__*/ _interop_require_default(require("./canResizeImage"));
const _cropImage = /*#__PURE__*/ _interop_require_default(require("./cropImage"));
const _getExternalFile = require("./getExternalFile");
const _getFileByPath = /*#__PURE__*/ _interop_require_default(require("./getFileByPath"));
const _getImageSize = /*#__PURE__*/ _interop_require_default(require("./getImageSize"));
const _getSafeFilename = /*#__PURE__*/ _interop_require_default(require("./getSafeFilename"));
const _imageResizer = /*#__PURE__*/ _interop_require_default(require("./imageResizer"));
const _isImage = /*#__PURE__*/ _interop_require_default(require("./isImage"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const generateFileData = async ({ collection: { config: collectionConfig }, config, data, overwriteExistingFiles, req, throwOnMissingFile })=>{
    if (!collectionConfig.upload) {
        return {
            data,
            files: []
        };
    }
    let file = req.files?.file || undefined;
    const { uploadEdits } = req.query || {};
    const { disableLocalStorage, formatOptions, imageSizes, resizeOptions, staticDir, trimOptions } = collectionConfig.upload;
    let staticPath = staticDir;
    if (staticDir.indexOf('/') !== 0) {
        staticPath = _path.default.resolve(config.paths.configDir, staticDir);
    }
    if (!file && uploadEdits && data) {
        const { filename, url } = data;
        try {
            if (url && url.startsWith('/') && !disableLocalStorage) {
                const filePath = `${staticPath}/${filename}`;
                const response = await (0, _getFileByPath.default)(filePath);
                file = response;
                overwriteExistingFiles = true;
            } else if (filename && url) {
                file = await (0, _getExternalFile.getExternalFile)({
                    data: data,
                    req,
                    uploadConfig: collectionConfig.upload
                });
                overwriteExistingFiles = true;
            }
        } catch (err) {
            if (err instanceof Error) {
                throw new _FileRetrievalError.default(req.t, err.message);
            }
        }
    }
    if (!file) {
        if (throwOnMissingFile) throw new _errors.MissingFile(req.t);
        return {
            data,
            files: []
        };
    }
    if (!disableLocalStorage) {
        _mkdirp.default.sync(staticPath);
    }
    let newData = data;
    const filesToSave = [];
    const fileData = {};
    const fileIsAnimated = file.mimetype === 'image/gif' || file.mimetype === 'image/webp';
    const cropData = typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined;
    try {
        const fileSupportsResize = (0, _canResizeImage.default)(file.mimetype);
        let fsSafeName;
        let sharpFile;
        let dimensions;
        let fileBuffer;
        let ext;
        let mime;
        const fileHasAdjustments = fileSupportsResize && Boolean(resizeOptions || formatOptions || trimOptions || file.tempFilePath);
        const sharpOptions = {};
        if (fileIsAnimated) sharpOptions.animated = true;
        if (fileHasAdjustments) {
            if (file.tempFilePath) {
                sharpFile = (0, _sharp.default)(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
                ;
            } else {
                sharpFile = (0, _sharp.default)(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
                ;
            }
            if (resizeOptions) {
                sharpFile = sharpFile.resize(resizeOptions);
            }
            if (formatOptions) {
                sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options);
            }
            if (trimOptions) {
                sharpFile = sharpFile.trim(trimOptions);
            }
        }
        if (fileSupportsResize || (0, _isImage.default)(file.mimetype)) {
            dimensions = await (0, _getImageSize.default)(file);
            fileData.width = dimensions.width;
            fileData.height = dimensions.height;
        }
        if (sharpFile) {
            const metadata = await sharpFile.metadata();
            fileBuffer = await sharpFile.toBuffer({
                resolveWithObject: true
            });
            ({ ext, mime } = await (0, _filetype.fromBuffer)(fileBuffer.data) // This is getting an incorrect gif height back.
            );
            fileData.width = fileBuffer.info.width;
            fileData.height = fileBuffer.info.height;
            fileData.filesize = fileBuffer.info.size;
            // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages
            if (metadata.pages) {
                fileData.height = fileBuffer.info.height / metadata.pages;
                fileData.filesize = fileBuffer.data.length;
            }
        } else {
            mime = file.mimetype;
            fileData.filesize = file.size;
            if (file.name.includes('.')) {
                ext = file.name.split('.').pop();
            } else {
                ext = '';
            }
        }
        // Adust SVG mime type. fromBuffer modifies it.
        if (mime === 'application/xml' && ext === 'svg') mime = 'image/svg+xml';
        fileData.mimeType = mime;
        const baseFilename = (0, _sanitizefilename.default)(file.name.substring(0, file.name.lastIndexOf('.')) || file.name);
        fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`;
        if (!overwriteExistingFiles) {
            fsSafeName = await (0, _getSafeFilename.default)({
                collectionSlug: collectionConfig.slug,
                desiredFilename: fsSafeName,
                req,
                staticPath
            });
        }
        fileData.filename = fsSafeName;
        let fileForResize = file;
        if (cropData) {
            const { data: croppedImage, info } = await (0, _cropImage.default)({
                cropData,
                dimensions,
                file
            });
            filesToSave.push({
                buffer: croppedImage,
                path: `${staticPath}/${fsSafeName}`
            });
            fileForResize = {
                ...file,
                data: croppedImage,
                size: info.size
            };
            fileData.width = info.width;
            fileData.height = info.height;
            fileData.filesize = info.size;
            if (file.tempFilePath) {
                await _fs.default.promises.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path
                ;
            } else {
                req.files.file = fileForResize;
            }
        } else {
            filesToSave.push({
                buffer: fileBuffer?.data || file.data,
                path: `${staticPath}/${fsSafeName}`
            });
            // If using temp files and the image is being resized, write the file to the temp path
            if (fileBuffer?.data || file.data.length > 0) {
                if (file.tempFilePath) {
                    await _fs.default.promises.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path
                    ;
                } else {
                    // Assign the _possibly modified_ file to the request object
                    req.files.file = {
                        ...file,
                        data: fileBuffer?.data || file.data,
                        size: fileBuffer?.info.size
                    };
                }
            }
        }
        if (Array.isArray(imageSizes) && fileSupportsResize) {
            req.payloadUploadSizes = {};
            const { sizeData, sizesToSave } = await (0, _imageResizer.default)({
                config: collectionConfig,
                dimensions: !cropData ? dimensions : {
                    ...dimensions,
                    height: fileData.height,
                    width: fileData.width
                },
                file: fileForResize,
                mimeType: fileData.mimeType,
                req,
                savedFilename: fsSafeName || file.name,
                staticPath
            });
            fileData.sizes = sizeData;
            filesToSave.push(...sizesToSave);
        }
    } catch (err) {
        console.error(err);
        throw new _errors.FileUploadError(req.t);
    }
    newData = {
        ...newData,
        ...fileData
    };
    return {
        data: newData,
        files: filesToSave
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2dlbmVyYXRlRmlsZURhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBVcGxvYWRlZEZpbGUgfSBmcm9tICdleHByZXNzLWZpbGV1cGxvYWQnXG5pbXBvcnQgdHlwZSB7IE91dHB1dEluZm8sIFNoYXJwLCBTaGFycE9wdGlvbnMgfSBmcm9tICdzaGFycCdcblxuaW1wb3J0IHsgZnJvbUJ1ZmZlciB9IGZyb20gJ2ZpbGUtdHlwZSdcbmltcG9ydCBmcyBmcm9tICdmcydcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBzYW5pdGl6ZSBmcm9tICdzYW5pdGl6ZS1maWxlbmFtZSdcbmltcG9ydCBzaGFycCBmcm9tICdzaGFycCdcblxuaW1wb3J0IHR5cGUgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb25maWcgfSBmcm9tICcuLi9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgRmlsZURhdGEsIEZpbGVUb1NhdmUsIFByb2JlZEltYWdlU2l6ZSB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IEZpbGVVcGxvYWRFcnJvciwgTWlzc2luZ0ZpbGUgfSBmcm9tICcuLi9lcnJvcnMnXG5pbXBvcnQgRmlsZVJldHJpZXZhbEVycm9yIGZyb20gJy4uL2Vycm9ycy9GaWxlUmV0cmlldmFsRXJyb3InXG5pbXBvcnQgY2FuUmVzaXplSW1hZ2UgZnJvbSAnLi9jYW5SZXNpemVJbWFnZSdcbmltcG9ydCBjcm9wSW1hZ2UgZnJvbSAnLi9jcm9wSW1hZ2UnXG5pbXBvcnQgeyBnZXRFeHRlcm5hbEZpbGUgfSBmcm9tICcuL2dldEV4dGVybmFsRmlsZSdcbmltcG9ydCBnZXRGaWxlQnlQYXRoIGZyb20gJy4vZ2V0RmlsZUJ5UGF0aCdcbmltcG9ydCBnZXRJbWFnZVNpemUgZnJvbSAnLi9nZXRJbWFnZVNpemUnXG5pbXBvcnQgZ2V0U2FmZUZpbGVOYW1lIGZyb20gJy4vZ2V0U2FmZUZpbGVuYW1lJ1xuaW1wb3J0IHJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMgZnJvbSAnLi9pbWFnZVJlc2l6ZXInXG5pbXBvcnQgaXNJbWFnZSBmcm9tICcuL2lzSW1hZ2UnXG5cbnR5cGUgQXJnczxUPiA9IHtcbiAgY29sbGVjdGlvbjogQ29sbGVjdGlvblxuICBjb25maWc6IFNhbml0aXplZENvbmZpZ1xuICBkYXRhOiBUXG4gIG92ZXJ3cml0ZUV4aXN0aW5nRmlsZXM/OiBib29sZWFuXG4gIHJlcTogUGF5bG9hZFJlcXVlc3RcbiAgdGhyb3dPbk1pc3NpbmdGaWxlPzogYm9vbGVhblxufVxuXG50eXBlIFJlc3VsdDxUPiA9IFByb21pc2U8e1xuICBkYXRhOiBUXG4gIGZpbGVzOiBGaWxlVG9TYXZlW11cbn0+XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUZpbGVEYXRhID0gYXN5bmMgPFQ+KHtcbiAgY29sbGVjdGlvbjogeyBjb25maWc6IGNvbGxlY3Rpb25Db25maWcgfSxcbiAgY29uZmlnLFxuICBkYXRhLFxuICBvdmVyd3JpdGVFeGlzdGluZ0ZpbGVzLFxuICByZXEsXG4gIHRocm93T25NaXNzaW5nRmlsZSxcbn06IEFyZ3M8VD4pOiBSZXN1bHQ8VD4gPT4ge1xuICBpZiAoIWNvbGxlY3Rpb25Db25maWcudXBsb2FkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBmaWxlczogW10sXG4gICAgfVxuICB9XG5cbiAgbGV0IGZpbGUgPSByZXEuZmlsZXM/LmZpbGUgfHwgdW5kZWZpbmVkXG4gIGNvbnN0IHsgdXBsb2FkRWRpdHMgfSA9IHJlcS5xdWVyeSB8fCB7fVxuXG4gIGNvbnN0IHsgZGlzYWJsZUxvY2FsU3RvcmFnZSwgZm9ybWF0T3B0aW9ucywgaW1hZ2VTaXplcywgcmVzaXplT3B0aW9ucywgc3RhdGljRGlyLCB0cmltT3B0aW9ucyB9ID1cbiAgICBjb2xsZWN0aW9uQ29uZmlnLnVwbG9hZFxuXG4gIGxldCBzdGF0aWNQYXRoID0gc3RhdGljRGlyXG4gIGlmIChzdGF0aWNEaXIuaW5kZXhPZignLycpICE9PSAwKSB7XG4gICAgc3RhdGljUGF0aCA9IHBhdGgucmVzb2x2ZShjb25maWcucGF0aHMuY29uZmlnRGlyLCBzdGF0aWNEaXIpXG4gIH1cblxuICBpZiAoIWZpbGUgJiYgdXBsb2FkRWRpdHMgJiYgZGF0YSkge1xuICAgIGNvbnN0IHsgZmlsZW5hbWUsIHVybCB9ID0gZGF0YSBhcyBGaWxlRGF0YVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh1cmwgJiYgdXJsLnN0YXJ0c1dpdGgoJy8nKSAmJiAhZGlzYWJsZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke3N0YXRpY1BhdGh9LyR7ZmlsZW5hbWV9YFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEZpbGVCeVBhdGgoZmlsZVBhdGgpXG4gICAgICAgIGZpbGUgPSByZXNwb25zZSBhcyBVcGxvYWRlZEZpbGVcbiAgICAgICAgb3ZlcndyaXRlRXhpc3RpbmdGaWxlcyA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgJiYgdXJsKSB7XG4gICAgICAgIGZpbGUgPSAoYXdhaXQgZ2V0RXh0ZXJuYWxGaWxlKHtcbiAgICAgICAgICBkYXRhOiBkYXRhIGFzIEZpbGVEYXRhLFxuICAgICAgICAgIHJlcSxcbiAgICAgICAgICB1cGxvYWRDb25maWc6IGNvbGxlY3Rpb25Db25maWcudXBsb2FkLFxuICAgICAgICB9KSkgYXMgVXBsb2FkZWRGaWxlXG4gICAgICAgIG92ZXJ3cml0ZUV4aXN0aW5nRmlsZXMgPSB0cnVlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpbGVSZXRyaWV2YWxFcnJvcihyZXEudCwgZXJyLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFmaWxlKSB7XG4gICAgaWYgKHRocm93T25NaXNzaW5nRmlsZSkgdGhyb3cgbmV3IE1pc3NpbmdGaWxlKHJlcS50KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBmaWxlczogW10sXG4gICAgfVxuICB9XG5cbiAgaWYgKCFkaXNhYmxlTG9jYWxTdG9yYWdlKSB7XG4gICAgbWtkaXJwLnN5bmMoc3RhdGljUGF0aClcbiAgfVxuXG4gIGxldCBuZXdEYXRhID0gZGF0YVxuICBjb25zdCBmaWxlc1RvU2F2ZTogRmlsZVRvU2F2ZVtdID0gW11cbiAgY29uc3QgZmlsZURhdGE6IFBhcnRpYWw8RmlsZURhdGE+ID0ge31cbiAgY29uc3QgZmlsZUlzQW5pbWF0ZWQgPSBmaWxlLm1pbWV0eXBlID09PSAnaW1hZ2UvZ2lmJyB8fCBmaWxlLm1pbWV0eXBlID09PSAnaW1hZ2Uvd2VicCdcbiAgY29uc3QgY3JvcERhdGEgPVxuICAgIHR5cGVvZiB1cGxvYWRFZGl0cyA9PT0gJ29iamVjdCcgJiYgJ2Nyb3AnIGluIHVwbG9hZEVkaXRzID8gdXBsb2FkRWRpdHMuY3JvcCA6IHVuZGVmaW5lZFxuXG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZVN1cHBvcnRzUmVzaXplID0gY2FuUmVzaXplSW1hZ2UoZmlsZS5taW1ldHlwZSlcbiAgICBsZXQgZnNTYWZlTmFtZTogc3RyaW5nXG4gICAgbGV0IHNoYXJwRmlsZTogU2hhcnAgfCB1bmRlZmluZWRcbiAgICBsZXQgZGltZW5zaW9uczogUHJvYmVkSW1hZ2VTaXplIHwgdW5kZWZpbmVkXG4gICAgbGV0IGZpbGVCdWZmZXI6IHsgZGF0YTogQnVmZmVyOyBpbmZvOiBPdXRwdXRJbmZvIH1cbiAgICBsZXQgZXh0XG4gICAgbGV0IG1pbWU6IHN0cmluZ1xuICAgIGNvbnN0IGZpbGVIYXNBZGp1c3RtZW50cyA9XG4gICAgICBmaWxlU3VwcG9ydHNSZXNpemUgJiZcbiAgICAgIEJvb2xlYW4ocmVzaXplT3B0aW9ucyB8fCBmb3JtYXRPcHRpb25zIHx8IHRyaW1PcHRpb25zIHx8IGZpbGUudGVtcEZpbGVQYXRoKVxuXG4gICAgY29uc3Qgc2hhcnBPcHRpb25zOiBTaGFycE9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKGZpbGVJc0FuaW1hdGVkKSBzaGFycE9wdGlvbnMuYW5pbWF0ZWQgPSB0cnVlXG5cbiAgICBpZiAoZmlsZUhhc0FkanVzdG1lbnRzKSB7XG4gICAgICBpZiAoZmlsZS50ZW1wRmlsZVBhdGgpIHtcbiAgICAgICAgc2hhcnBGaWxlID0gc2hhcnAoZmlsZS50ZW1wRmlsZVBhdGgsIHNoYXJwT3B0aW9ucykucm90YXRlKCkgLy8gcGFzcyByb3RhdGUoKSB0byBhdXRvLXJvdGF0ZSBiYXNlZCBvbiBFWElGIGRhdGEuIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXlsb2FkY21zL3BheWxvYWQvcHVsbC8zMDgxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFycEZpbGUgPSBzaGFycChmaWxlLmRhdGEsIHNoYXJwT3B0aW9ucykucm90YXRlKCkgLy8gcGFzcyByb3RhdGUoKSB0byBhdXRvLXJvdGF0ZSBiYXNlZCBvbiBFWElGIGRhdGEuIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXlsb2FkY21zL3BheWxvYWQvcHVsbC8zMDgxXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNpemVPcHRpb25zKSB7XG4gICAgICAgIHNoYXJwRmlsZSA9IHNoYXJwRmlsZS5yZXNpemUocmVzaXplT3B0aW9ucylcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXRPcHRpb25zKSB7XG4gICAgICAgIHNoYXJwRmlsZSA9IHNoYXJwRmlsZS50b0Zvcm1hdChmb3JtYXRPcHRpb25zLmZvcm1hdCwgZm9ybWF0T3B0aW9ucy5vcHRpb25zKVxuICAgICAgfVxuICAgICAgaWYgKHRyaW1PcHRpb25zKSB7XG4gICAgICAgIHNoYXJwRmlsZSA9IHNoYXJwRmlsZS50cmltKHRyaW1PcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaWxlU3VwcG9ydHNSZXNpemUgfHwgaXNJbWFnZShmaWxlLm1pbWV0eXBlKSkge1xuICAgICAgZGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlU2l6ZShmaWxlKVxuICAgICAgZmlsZURhdGEud2lkdGggPSBkaW1lbnNpb25zLndpZHRoXG4gICAgICBmaWxlRGF0YS5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodFxuICAgIH1cblxuICAgIGlmIChzaGFycEZpbGUpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgc2hhcnBGaWxlLm1ldGFkYXRhKClcbiAgICAgIGZpbGVCdWZmZXIgPSBhd2FpdCBzaGFycEZpbGUudG9CdWZmZXIoeyByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSB9KVxuICAgICAgOyh7IGV4dCwgbWltZSB9ID0gYXdhaXQgZnJvbUJ1ZmZlcihmaWxlQnVmZmVyLmRhdGEpKSAvLyBUaGlzIGlzIGdldHRpbmcgYW4gaW5jb3JyZWN0IGdpZiBoZWlnaHQgYmFjay5cbiAgICAgIGZpbGVEYXRhLndpZHRoID0gZmlsZUJ1ZmZlci5pbmZvLndpZHRoXG4gICAgICBmaWxlRGF0YS5oZWlnaHQgPSBmaWxlQnVmZmVyLmluZm8uaGVpZ2h0XG4gICAgICBmaWxlRGF0YS5maWxlc2l6ZSA9IGZpbGVCdWZmZXIuaW5mby5zaXplXG5cbiAgICAgIC8vIEFuaW1hdGVkIEdJRnMgKyBXZWJQIGFnZ3JlZ2F0ZSB0aGUgaGVpZ2h0IGZyb20gZXZlcnkgZnJhbWUsIHNvIHdlIG5lZWQgdG8gdXNlIGRpdmlkZSBieSBudW1iZXIgb2YgcGFnZXNcbiAgICAgIGlmIChtZXRhZGF0YS5wYWdlcykge1xuICAgICAgICBmaWxlRGF0YS5oZWlnaHQgPSBmaWxlQnVmZmVyLmluZm8uaGVpZ2h0IC8gbWV0YWRhdGEucGFnZXNcbiAgICAgICAgZmlsZURhdGEuZmlsZXNpemUgPSBmaWxlQnVmZmVyLmRhdGEubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbWUgPSBmaWxlLm1pbWV0eXBlXG4gICAgICBmaWxlRGF0YS5maWxlc2l6ZSA9IGZpbGUuc2l6ZVxuXG4gICAgICBpZiAoZmlsZS5uYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgZXh0ID0gZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dCA9ICcnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWR1c3QgU1ZHIG1pbWUgdHlwZS4gZnJvbUJ1ZmZlciBtb2RpZmllcyBpdC5cbiAgICBpZiAobWltZSA9PT0gJ2FwcGxpY2F0aW9uL3htbCcgJiYgZXh0ID09PSAnc3ZnJykgbWltZSA9ICdpbWFnZS9zdmcreG1sJ1xuICAgIGZpbGVEYXRhLm1pbWVUeXBlID0gbWltZVxuXG4gICAgY29uc3QgYmFzZUZpbGVuYW1lID0gc2FuaXRpemUoZmlsZS5uYW1lLnN1YnN0cmluZygwLCBmaWxlLm5hbWUubGFzdEluZGV4T2YoJy4nKSkgfHwgZmlsZS5uYW1lKVxuICAgIGZzU2FmZU5hbWUgPSBgJHtiYXNlRmlsZW5hbWV9JHtleHQgPyBgLiR7ZXh0fWAgOiAnJ31gXG5cbiAgICBpZiAoIW92ZXJ3cml0ZUV4aXN0aW5nRmlsZXMpIHtcbiAgICAgIGZzU2FmZU5hbWUgPSBhd2FpdCBnZXRTYWZlRmlsZU5hbWUoe1xuICAgICAgICBjb2xsZWN0aW9uU2x1ZzogY29sbGVjdGlvbkNvbmZpZy5zbHVnLFxuICAgICAgICBkZXNpcmVkRmlsZW5hbWU6IGZzU2FmZU5hbWUsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc3RhdGljUGF0aCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZmlsZURhdGEuZmlsZW5hbWUgPSBmc1NhZmVOYW1lXG4gICAgbGV0IGZpbGVGb3JSZXNpemUgPSBmaWxlXG5cbiAgICBpZiAoY3JvcERhdGEpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogY3JvcHBlZEltYWdlLCBpbmZvIH0gPSBhd2FpdCBjcm9wSW1hZ2UoeyBjcm9wRGF0YSwgZGltZW5zaW9ucywgZmlsZSB9KVxuXG4gICAgICBmaWxlc1RvU2F2ZS5wdXNoKHtcbiAgICAgICAgYnVmZmVyOiBjcm9wcGVkSW1hZ2UsXG4gICAgICAgIHBhdGg6IGAke3N0YXRpY1BhdGh9LyR7ZnNTYWZlTmFtZX1gLFxuICAgICAgfSlcblxuICAgICAgZmlsZUZvclJlc2l6ZSA9IHtcbiAgICAgICAgLi4uZmlsZSxcbiAgICAgICAgZGF0YTogY3JvcHBlZEltYWdlLFxuICAgICAgICBzaXplOiBpbmZvLnNpemUsXG4gICAgICB9XG4gICAgICBmaWxlRGF0YS53aWR0aCA9IGluZm8ud2lkdGhcbiAgICAgIGZpbGVEYXRhLmhlaWdodCA9IGluZm8uaGVpZ2h0XG4gICAgICBmaWxlRGF0YS5maWxlc2l6ZSA9IGluZm8uc2l6ZVxuXG4gICAgICBpZiAoZmlsZS50ZW1wRmlsZVBhdGgpIHtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKGZpbGUudGVtcEZpbGVQYXRoLCBjcm9wcGVkSW1hZ2UpIC8vIHdyaXRlIGZpbGVCdWZmZXIgdG8gdGhlIHRlbXAgcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLmZpbGVzLmZpbGUgPSBmaWxlRm9yUmVzaXplXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGVzVG9TYXZlLnB1c2goe1xuICAgICAgICBidWZmZXI6IGZpbGVCdWZmZXI/LmRhdGEgfHwgZmlsZS5kYXRhLFxuICAgICAgICBwYXRoOiBgJHtzdGF0aWNQYXRofS8ke2ZzU2FmZU5hbWV9YCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIElmIHVzaW5nIHRlbXAgZmlsZXMgYW5kIHRoZSBpbWFnZSBpcyBiZWluZyByZXNpemVkLCB3cml0ZSB0aGUgZmlsZSB0byB0aGUgdGVtcCBwYXRoXG4gICAgICBpZiAoZmlsZUJ1ZmZlcj8uZGF0YSB8fCBmaWxlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmlsZS50ZW1wRmlsZVBhdGgpIHtcbiAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUoZmlsZS50ZW1wRmlsZVBhdGgsIGZpbGVCdWZmZXI/LmRhdGEgfHwgZmlsZS5kYXRhKSAvLyB3cml0ZSBmaWxlQnVmZmVyIHRvIHRoZSB0ZW1wIHBhdGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBc3NpZ24gdGhlIF9wb3NzaWJseSBtb2RpZmllZF8gZmlsZSB0byB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICByZXEuZmlsZXMuZmlsZSA9IHtcbiAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICBkYXRhOiBmaWxlQnVmZmVyPy5kYXRhIHx8IGZpbGUuZGF0YSxcbiAgICAgICAgICAgIHNpemU6IGZpbGVCdWZmZXI/LmluZm8uc2l6ZSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbWFnZVNpemVzKSAmJiBmaWxlU3VwcG9ydHNSZXNpemUpIHtcbiAgICAgIHJlcS5wYXlsb2FkVXBsb2FkU2l6ZXMgPSB7fVxuICAgICAgY29uc3QgeyBzaXplRGF0YSwgc2l6ZXNUb1NhdmUgfSA9IGF3YWl0IHJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMoe1xuICAgICAgICBjb25maWc6IGNvbGxlY3Rpb25Db25maWcsXG4gICAgICAgIGRpbWVuc2lvbnM6ICFjcm9wRGF0YVxuICAgICAgICAgID8gZGltZW5zaW9uc1xuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAuLi5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGZpbGVEYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGZpbGVEYXRhLndpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgZmlsZTogZmlsZUZvclJlc2l6ZSxcbiAgICAgICAgbWltZVR5cGU6IGZpbGVEYXRhLm1pbWVUeXBlLFxuICAgICAgICByZXEsXG4gICAgICAgIHNhdmVkRmlsZW5hbWU6IGZzU2FmZU5hbWUgfHwgZmlsZS5uYW1lLFxuICAgICAgICBzdGF0aWNQYXRoLFxuICAgICAgfSlcblxuICAgICAgZmlsZURhdGEuc2l6ZXMgPSBzaXplRGF0YVxuICAgICAgZmlsZXNUb1NhdmUucHVzaCguLi5zaXplc1RvU2F2ZSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgIHRocm93IG5ldyBGaWxlVXBsb2FkRXJyb3IocmVxLnQpXG4gIH1cblxuICBuZXdEYXRhID0ge1xuICAgIC4uLm5ld0RhdGEsXG4gICAgLi4uZmlsZURhdGEsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGE6IG5ld0RhdGEsXG4gICAgZmlsZXM6IGZpbGVzVG9TYXZlLFxuICB9XG59XG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVGaWxlRGF0YSIsImNvbGxlY3Rpb24iLCJjb25maWciLCJjb2xsZWN0aW9uQ29uZmlnIiwiZGF0YSIsIm92ZXJ3cml0ZUV4aXN0aW5nRmlsZXMiLCJyZXEiLCJ0aHJvd09uTWlzc2luZ0ZpbGUiLCJ1cGxvYWQiLCJmaWxlcyIsImZpbGUiLCJ1bmRlZmluZWQiLCJ1cGxvYWRFZGl0cyIsInF1ZXJ5IiwiZGlzYWJsZUxvY2FsU3RvcmFnZSIsImZvcm1hdE9wdGlvbnMiLCJpbWFnZVNpemVzIiwicmVzaXplT3B0aW9ucyIsInN0YXRpY0RpciIsInRyaW1PcHRpb25zIiwic3RhdGljUGF0aCIsImluZGV4T2YiLCJwYXRoIiwicmVzb2x2ZSIsInBhdGhzIiwiY29uZmlnRGlyIiwiZmlsZW5hbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwiZmlsZVBhdGgiLCJyZXNwb25zZSIsImdldEZpbGVCeVBhdGgiLCJnZXRFeHRlcm5hbEZpbGUiLCJ1cGxvYWRDb25maWciLCJlcnIiLCJFcnJvciIsIkZpbGVSZXRyaWV2YWxFcnJvciIsInQiLCJtZXNzYWdlIiwiTWlzc2luZ0ZpbGUiLCJta2RpcnAiLCJzeW5jIiwibmV3RGF0YSIsImZpbGVzVG9TYXZlIiwiZmlsZURhdGEiLCJmaWxlSXNBbmltYXRlZCIsIm1pbWV0eXBlIiwiY3JvcERhdGEiLCJjcm9wIiwiZmlsZVN1cHBvcnRzUmVzaXplIiwiY2FuUmVzaXplSW1hZ2UiLCJmc1NhZmVOYW1lIiwic2hhcnBGaWxlIiwiZGltZW5zaW9ucyIsImZpbGVCdWZmZXIiLCJleHQiLCJtaW1lIiwiZmlsZUhhc0FkanVzdG1lbnRzIiwiQm9vbGVhbiIsInRlbXBGaWxlUGF0aCIsInNoYXJwT3B0aW9ucyIsImFuaW1hdGVkIiwic2hhcnAiLCJyb3RhdGUiLCJyZXNpemUiLCJ0b0Zvcm1hdCIsImZvcm1hdCIsIm9wdGlvbnMiLCJ0cmltIiwiaXNJbWFnZSIsImdldEltYWdlU2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwibWV0YWRhdGEiLCJ0b0J1ZmZlciIsInJlc29sdmVXaXRoT2JqZWN0IiwiZnJvbUJ1ZmZlciIsImluZm8iLCJmaWxlc2l6ZSIsInNpemUiLCJwYWdlcyIsImxlbmd0aCIsIm5hbWUiLCJpbmNsdWRlcyIsInNwbGl0IiwicG9wIiwibWltZVR5cGUiLCJiYXNlRmlsZW5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZ2V0U2FmZUZpbGVOYW1lIiwiY29sbGVjdGlvblNsdWciLCJzbHVnIiwiZGVzaXJlZEZpbGVuYW1lIiwiZmlsZUZvclJlc2l6ZSIsImNyb3BwZWRJbWFnZSIsImNyb3BJbWFnZSIsInB1c2giLCJidWZmZXIiLCJmcyIsInByb21pc2VzIiwid3JpdGVGaWxlIiwiQXJyYXkiLCJpc0FycmF5IiwicGF5bG9hZFVwbG9hZFNpemVzIiwic2l6ZURhdGEiLCJzaXplc1RvU2F2ZSIsInJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMiLCJzYXZlZEZpbGVuYW1lIiwic2l6ZXMiLCJjb25zb2xlIiwiZXJyb3IiLCJGaWxlVXBsb2FkRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7K0JBd0NhQTs7O2VBQUFBOzs7MEJBckNjOzJEQUNaOytEQUNJ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