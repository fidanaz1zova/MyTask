"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    array: function() {
        return array;
    },
    blocks: function() {
        return blocks;
    },
    checkbox: function() {
        return checkbox;
    },
    code: function() {
        return code;
    },
    date: function() {
        return date;
    },
    default: function() {
        return _default;
    },
    email: function() {
        return email;
    },
    json: function() {
        return json;
    },
    number: function() {
        return number;
    },
    password: function() {
        return password;
    },
    point: function() {
        return point;
    },
    radio: function() {
        return radio;
    },
    relationship: function() {
        return relationship;
    },
    richText: function() {
        return richText;
    },
    select: function() {
        return select;
    },
    text: function() {
        return text;
    },
    textarea: function() {
        return textarea;
    },
    upload: function() {
        return upload;
    }
});
const _ajv = /*#__PURE__*/ _interop_require_default(require("ajv"));
const _canUseDOM = /*#__PURE__*/ _interop_require_default(require("../utilities/canUseDOM"));
const _getIDType = require("../utilities/getIDType");
const _isNumber = require("../utilities/isNumber");
const _isValidID = require("../utilities/isValidID");
const _types = require("./config/types");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const text = (value, { config, hasMany, maxLength: fieldMaxLength, maxRows, minLength, minRows, required, t })=>{
    let maxLength;
    if (!required) {
        if (!value) return true;
    }
    if (hasMany === true) {
        const lengthValidationResult = validateArrayLength(value, {
            maxRows,
            minRows,
            required,
            t
        });
        if (typeof lengthValidationResult === 'string') return lengthValidationResult;
    }
    if (typeof config?.defaultMaxTextLength === 'number') maxLength = config.defaultMaxTextLength;
    if (typeof fieldMaxLength === 'number') maxLength = fieldMaxLength;
    const stringsToValidate = Array.isArray(value) ? value : [
        value
    ];
    for (const stringValue of stringsToValidate){
        const length = stringValue?.length || 0;
        if (typeof maxLength === 'number' && length > maxLength) {
            return t('validation:shorterThanMax', {
                label: t('value'),
                maxLength,
                stringValue
            });
        }
        if (typeof minLength === 'number' && length < minLength) {
            return t('validation:longerThanMin', {
                label: t('value'),
                minLength,
                stringValue
            });
        }
    }
    if (required) {
        if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {
            return t('validation:required');
        }
    }
    return true;
};
const password = (value, { config, maxLength: fieldMaxLength, minLength, payload, required, t })=>{
    let maxLength;
    if (typeof config?.defaultMaxTextLength === 'number') maxLength = config.defaultMaxTextLength;
    if (typeof fieldMaxLength === 'number') maxLength = fieldMaxLength;
    if (value && maxLength && value.length > maxLength) {
        return t('validation:shorterThanMax', {
            maxLength
        });
    }
    if (value && minLength && value.length < minLength) {
        return t('validation:longerThanMin', {
            minLength
        });
    }
    if (required && !value) {
        return t('validation:required');
    }
    return true;
};
const email = (value, { required, t })=>{
    if (value && !/\S[^\s@]*@\S+\.\S+/.test(value) || !value && required) {
        return t('validation:emailAddress');
    }
    return true;
};
const textarea = (value, { config, maxLength: fieldMaxLength, minLength, payload, required, t })=>{
    let maxLength;
    if (typeof config?.defaultMaxTextLength === 'number') maxLength = config.defaultMaxTextLength;
    if (typeof fieldMaxLength === 'number') maxLength = fieldMaxLength;
    if (value && maxLength && value.length > maxLength) {
        return t('validation:shorterThanMax', {
            maxLength
        });
    }
    if (value && minLength && value.length < minLength) {
        return t('validation:longerThanMin', {
            minLength
        });
    }
    if (required && !value) {
        return t('validation:required');
    }
    return true;
};
const code = (value, { required, t })=>{
    if (required && value === undefined) {
        return t('validation:required');
    }
    return true;
};
const json = async (value, { jsonError, jsonSchema, required, t })=>{
    if (required && !value) {
        return t('validation:required');
    }
    if (jsonError !== undefined) {
        return t('validation:invalidInput');
    }
    const isNotEmpty = (value)=>{
        if (value === undefined || value === null) {
            return false;
        }
        if (Array.isArray(value) && value.length === 0) {
            return false;
        }
        if (typeof value === 'object' && Object.keys(value).length === 0) {
            return false;
        }
        return true;
    };
    const fetchSchema = ({ uri, schema })=>{
        if (uri && schema) return schema;
        return fetch(uri).then((response)=>{
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        }).then((json)=>{
            const jsonSchemaSanitizations = {
                id: undefined,
                $id: json.id,
                $schema: 'http://json-schema.org/draft-07/schema#'
            };
            return Object.assign(json, jsonSchemaSanitizations);
        });
    };
    if (!_canUseDOM.default && jsonSchema && isNotEmpty(value)) {
        try {
            jsonSchema.schema = await fetchSchema(jsonSchema);
            const { schema } = jsonSchema;
            const ajv = new _ajv.default();
            if (!ajv.validate(schema, value)) {
                return t(ajv.errorsText());
            }
        } catch (error) {
            return t(error.message);
        }
    }
    return true;
};
const checkbox = (value, { required, t })=>{
    if (value && typeof value !== 'boolean' || required && typeof value !== 'boolean') {
        return t('validation:trueOrFalse');
    }
    return true;
};
const date = (value, { required, t })=>{
    if (value && !isNaN(Date.parse(value.toString()))) {
        /* eslint-disable-line */ return true;
    }
    if (value) {
        return t('validation:notValidDate', {
            value
        });
    }
    if (required) {
        return t('validation:required');
    }
    return true;
};
const richText = async (value, options)=>{
    const editor = options?.editor;
    return await editor.validate(value, options);
};
const validateArrayLength = (value, options)=>{
    const { maxRows, minRows, required, t } = options;
    const arrayLength = Array.isArray(value) ? value.length : 0;
    if (!required && arrayLength === 0) return true;
    if (minRows && arrayLength < minRows) {
        return t('validation:requiresAtLeast', {
            count: minRows,
            label: t('rows')
        });
    }
    if (maxRows && arrayLength > maxRows) {
        return t('validation:requiresNoMoreThan', {
            count: maxRows,
            label: t('rows')
        });
    }
    if (required && !arrayLength) {
        return t('validation:requiresAtLeast', {
            count: 1,
            label: t('row')
        });
    }
    return true;
};
const number = (value, { hasMany, max, maxRows, min, minRows, required, t })=>{
    if (hasMany === true) {
        const lengthValidationResult = validateArrayLength(value, {
            maxRows,
            minRows,
            required,
            t
        });
        if (typeof lengthValidationResult === 'string') return lengthValidationResult;
    }
    if (!value && !(0, _isNumber.isNumber)(value)) {
        // if no value is present, validate based on required
        if (required) return t('validation:required');
        if (!required) return true;
    }
    const numbersToValidate = Array.isArray(value) ? value : [
        value
    ];
    for (const number of numbersToValidate){
        if (!(0, _isNumber.isNumber)(number)) return t('validation:enterNumber');
        const numberValue = parseFloat(number);
        if (typeof max === 'number' && numberValue > max) {
            return t('validation:greaterThanMax', {
                label: t('value'),
                max,
                value
            });
        }
        if (typeof min === 'number' && numberValue < min) {
            return t('validation:lessThanMin', {
                label: t('value'),
                min,
                value
            });
        }
    }
    return true;
};
const array = (value, { maxRows, minRows, required, t })=>{
    return validateArrayLength(value, {
        maxRows,
        minRows,
        required,
        t
    });
};
const blocks = (value, { maxRows, minRows, required, t })=>{
    return validateArrayLength(value, {
        maxRows,
        minRows,
        required,
        t
    });
};
const validateFilterOptions = async (value, { id, data, filterOptions, payload, relationTo, req, siblingData, t, user })=>{
    if (!_canUseDOM.default && typeof filterOptions !== 'undefined' && value) {
        const options = {};
        const falseCollections = [];
        const collections = typeof relationTo === 'string' ? [
            relationTo
        ] : relationTo;
        const values = Array.isArray(value) ? value : [
            value
        ];
        await Promise.all(collections.map(async (collection)=>{
            try {
                let optionFilter = typeof filterOptions === 'function' ? await filterOptions({
                    id,
                    data,
                    relationTo: collection,
                    siblingData,
                    user
                }) : filterOptions;
                if (optionFilter === true) {
                    optionFilter = null;
                }
                const valueIDs = [];
                values.forEach((val)=>{
                    if (typeof val === 'object' && val?.value) {
                        valueIDs.push(val.value);
                    }
                    if (typeof val === 'string' || typeof val === 'number') {
                        valueIDs.push(val);
                    }
                });
                if (valueIDs.length > 0) {
                    const findWhere = {
                        and: [
                            {
                                id: {
                                    in: valueIDs
                                }
                            }
                        ]
                    };
                    if (optionFilter) findWhere.and.push(optionFilter);
                    if (optionFilter === false) {
                        falseCollections.push(optionFilter);
                    }
                    const result = await payload.find({
                        collection,
                        depth: 0,
                        limit: 0,
                        pagination: false,
                        req,
                        where: findWhere
                    });
                    options[collection] = result.docs.map((doc)=>doc.id);
                } else {
                    options[collection] = [];
                }
            } catch (err) {
                req.payload.logger.error({
                    err,
                    msg: `Error validating filter options for collection ${collection}`
                });
                options[collection] = [];
            }
        }));
        const invalidRelationships = values.filter((val)=>{
            let collection;
            let requestedID;
            if (typeof relationTo === 'string') {
                collection = relationTo;
                if (typeof val === 'string' || typeof val === 'number') {
                    requestedID = val;
                }
            }
            if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {
                collection = val.relationTo;
                requestedID = val.value;
            }
            if (falseCollections.find((slug)=>relationTo === slug)) {
                return true;
            }
            return options[collection].indexOf(requestedID) === -1;
        });
        if (invalidRelationships.length > 0) {
            return invalidRelationships.reduce((err, invalid, i)=>{
                return `${err} ${JSON.stringify(invalid)}${invalidRelationships.length === i + 1 ? ',' : ''} `;
            }, t('validation:invalidSelections'));
        }
        return true;
    }
    return true;
};
const upload = (value, options)=>{
    if (!value && options.required) {
        return options.t('validation:required');
    }
    if (!_canUseDOM.default && typeof value !== 'undefined' && value !== null) {
        const idField = options?.config?.collections?.find((collection)=>collection.slug === options.relationTo)?.fields?.find((field)=>(0, _types.fieldAffectsData)(field) && field.name === 'id');
        const type = (0, _getIDType.getIDType)(idField, options?.payload?.db?.defaultIDType);
        if (!(0, _isValidID.isValidID)(value, type)) {
            return options.t('validation:validUploadID');
        }
    }
    return validateFilterOptions(value, options);
};
const relationship = async (value, options)=>{
    const { config, maxRows, minRows, payload, relationTo, required, t } = options;
    if ((!value || Array.isArray(value) && value.length === 0) && required) {
        return t('validation:required');
    }
    if (Array.isArray(value) && value.length > 0) {
        if (minRows && value.length < minRows) {
            return t('validation:lessThanMin', {
                label: t('rows'),
                min: minRows,
                value: value.length
            });
        }
        if (maxRows && value.length > maxRows) {
            return t('validation:greaterThanMax', {
                label: t('rows'),
                max: maxRows,
                value: value.length
            });
        }
    }
    if (!_canUseDOM.default && typeof value !== 'undefined' && value !== null) {
        const values = Array.isArray(value) ? value : [
            value
        ];
        const invalidRelationships = values.filter((val)=>{
            let collectionSlug;
            let requestedID;
            if (typeof relationTo === 'string') {
                collectionSlug = relationTo;
                // custom id
                if (val) {
                    requestedID = val;
                }
            }
            if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {
                collectionSlug = val.relationTo;
                requestedID = val.value;
            }
            if (requestedID === null) return false;
            const idField = config?.collections?.find((collection)=>collection.slug === collectionSlug)?.fields?.find((field)=>(0, _types.fieldAffectsData)(field) && field.name === 'id');
            const type = (0, _getIDType.getIDType)(idField, payload?.db?.defaultIDType);
            return !(0, _isValidID.isValidID)(requestedID, type);
        });
        if (invalidRelationships.length > 0) {
            return `This relationship field has the following invalid relationships: ${invalidRelationships.map((err, invalid)=>{
                return `${err} ${JSON.stringify(invalid)}`;
            }).join(', ')}`;
        }
    }
    return validateFilterOptions(value, options);
};
const select = (value, { hasMany, options, required, t })=>{
    if (Array.isArray(value) && value.some((input)=>!options.some((option)=>option === input || typeof option !== 'string' && option?.value === input))) {
        return t('validation:invalidSelection');
    }
    if (typeof value === 'string' && !options.some((option)=>option === value || typeof option !== 'string' && option.value === value)) {
        return t('validation:invalidSelection');
    }
    if (required && (typeof value === 'undefined' || value === null || hasMany && Array.isArray(value) && value?.length === 0)) {
        return t('validation:required');
    }
    return true;
};
const radio = (value, { options, required, t })=>{
    if (value) {
        const valueMatchesOption = options.some((option)=>option === value || typeof option !== 'string' && option.value === value);
        return valueMatchesOption || t('validation:invalidSelection');
    }
    return required ? t('validation:required') : true;
};
const point = (value = [
    '',
    ''
], { required, t })=>{
    const lng = parseFloat(String(value[0]));
    const lat = parseFloat(String(value[1]));
    if (required && (value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number' || Number.isNaN(lng) || Number.isNaN(lat) || Array.isArray(value) && value.length !== 2)) {
        return t('validation:requiresTwoNumbers');
    }
    if (value[1] && Number.isNaN(lng) || value[0] && Number.isNaN(lat)) {
        return t('validation:invalidInput');
    }
    return true;
};
const _default = {
    array,
    blocks,
    checkbox,
    code,
    date,
    email,
    json,
    number,
    password,
    point,
    radio,
    relationship,
    richText,
    select,
    text,
    textarea,
    upload
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9maWVsZHMvdmFsaWRhdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFqdiBmcm9tICdhanYnXG5pbXBvcnQgdHlwZSB7IFJpY2hUZXh0QWRhcHRlciB9IGZyb20gJy4uL2V4cG9ydHMvdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIEFycmF5RmllbGQsXG4gIEJsb2NrRmllbGQsXG4gIENoZWNrYm94RmllbGQsXG4gIENvZGVGaWVsZCxcbiAgRGF0ZUZpZWxkLFxuICBFbWFpbEZpZWxkLFxuICBKU09ORmllbGQsXG4gIE51bWJlckZpZWxkLFxuICBQb2ludEZpZWxkLFxuICBSYWRpb0ZpZWxkLFxuICBSZWxhdGlvbnNoaXBGaWVsZCxcbiAgUmVsYXRpb25zaGlwVmFsdWUsXG4gIFJpY2hUZXh0RmllbGQsXG4gIFNlbGVjdEZpZWxkLFxuICBUZXh0RmllbGQsXG4gIFRleHRhcmVhRmllbGQsXG4gIFVwbG9hZEZpZWxkLFxuICBWYWxpZGF0ZSxcbn0gZnJvbSAnLi9jb25maWcvdHlwZXMnXG5cbmltcG9ydCBjYW5Vc2VET00gZnJvbSAnLi4vdXRpbGl0aWVzL2NhblVzZURPTSdcbmltcG9ydCB7IGdldElEVHlwZSB9IGZyb20gJy4uL3V0aWxpdGllcy9nZXRJRFR5cGUnXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4uL3V0aWxpdGllcy9pc051bWJlcidcbmltcG9ydCB7IGlzVmFsaWRJRCB9IGZyb20gJy4uL3V0aWxpdGllcy9pc1ZhbGlkSUQnXG5pbXBvcnQgeyBmaWVsZEFmZmVjdHNEYXRhIH0gZnJvbSAnLi9jb25maWcvdHlwZXMnXG5cbmV4cG9ydCBjb25zdCB0ZXh0OiBWYWxpZGF0ZTx1bmtub3duLCB1bmtub3duLCBUZXh0RmllbGQ+ID0gKFxuICB2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10sXG4gIHsgY29uZmlnLCBoYXNNYW55LCBtYXhMZW5ndGg6IGZpZWxkTWF4TGVuZ3RoLCBtYXhSb3dzLCBtaW5MZW5ndGgsIG1pblJvd3MsIHJlcXVpcmVkLCB0IH0sXG4pID0+IHtcbiAgbGV0IG1heExlbmd0aDogbnVtYmVyXG5cbiAgaWYgKCFyZXF1aXJlZCkge1xuICAgIGlmICghdmFsdWUpIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoaGFzTWFueSA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IGxlbmd0aFZhbGlkYXRpb25SZXN1bHQgPSB2YWxpZGF0ZUFycmF5TGVuZ3RoKHZhbHVlLCB7IG1heFJvd3MsIG1pblJvd3MsIHJlcXVpcmVkLCB0IH0pXG4gICAgaWYgKHR5cGVvZiBsZW5ndGhWYWxpZGF0aW9uUmVzdWx0ID09PSAnc3RyaW5nJykgcmV0dXJuIGxlbmd0aFZhbGlkYXRpb25SZXN1bHRcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnPy5kZWZhdWx0TWF4VGV4dExlbmd0aCA9PT0gJ251bWJlcicpIG1heExlbmd0aCA9IGNvbmZpZy5kZWZhdWx0TWF4VGV4dExlbmd0aFxuICBpZiAodHlwZW9mIGZpZWxkTWF4TGVuZ3RoID09PSAnbnVtYmVyJykgbWF4TGVuZ3RoID0gZmllbGRNYXhMZW5ndGhcblxuICBjb25zdCBzdHJpbmdzVG9WYWxpZGF0ZTogc3RyaW5nW10gPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXVxuXG4gIGZvciAoY29uc3Qgc3RyaW5nVmFsdWUgb2Ygc3RyaW5nc1RvVmFsaWRhdGUpIHtcbiAgICBjb25zdCBsZW5ndGggPSBzdHJpbmdWYWx1ZT8ubGVuZ3RoIHx8IDBcblxuICAgIGlmICh0eXBlb2YgbWF4TGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnNob3J0ZXJUaGFuTWF4JywgeyBsYWJlbDogdCgndmFsdWUnKSwgbWF4TGVuZ3RoLCBzdHJpbmdWYWx1ZSB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWluTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW5ndGggPCBtaW5MZW5ndGgpIHtcbiAgICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOmxvbmdlclRoYW5NaW4nLCB7IGxhYmVsOiB0KCd2YWx1ZScpLCBtaW5MZW5ndGgsIHN0cmluZ1ZhbHVlIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcXVpcmVkKSB7XG4gICAgaWYgKCEodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkgfHwgdmFsdWU/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246cmVxdWlyZWQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCBwYXNzd29yZDogVmFsaWRhdGU8dW5rbm93biwgdW5rbm93biwgVGV4dEZpZWxkPiA9IChcbiAgdmFsdWU6IHN0cmluZyxcbiAgeyBjb25maWcsIG1heExlbmd0aDogZmllbGRNYXhMZW5ndGgsIG1pbkxlbmd0aCwgcGF5bG9hZCwgcmVxdWlyZWQsIHQgfSxcbikgPT4ge1xuICBsZXQgbWF4TGVuZ3RoOiBudW1iZXJcblxuICBpZiAodHlwZW9mIGNvbmZpZz8uZGVmYXVsdE1heFRleHRMZW5ndGggPT09ICdudW1iZXInKSBtYXhMZW5ndGggPSBjb25maWcuZGVmYXVsdE1heFRleHRMZW5ndGhcbiAgaWYgKHR5cGVvZiBmaWVsZE1heExlbmd0aCA9PT0gJ251bWJlcicpIG1heExlbmd0aCA9IGZpZWxkTWF4TGVuZ3RoXG5cbiAgaWYgKHZhbHVlICYmIG1heExlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICByZXR1cm4gdCgndmFsaWRhdGlvbjpzaG9ydGVyVGhhbk1heCcsIHsgbWF4TGVuZ3RoIH0pXG4gIH1cblxuICBpZiAodmFsdWUgJiYgbWluTGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOmxvbmdlclRoYW5NaW4nLCB7IG1pbkxlbmd0aCB9KVxuICB9XG5cbiAgaWYgKHJlcXVpcmVkICYmICF2YWx1ZSkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnJlcXVpcmVkJylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCBlbWFpbDogVmFsaWRhdGU8dW5rbm93biwgdW5rbm93biwgRW1haWxGaWVsZD4gPSAodmFsdWU6IHN0cmluZywgeyByZXF1aXJlZCwgdCB9KSA9PiB7XG4gIGlmICgodmFsdWUgJiYgIS9cXFNbXlxcc0BdKkBcXFMrXFwuXFxTKy8udGVzdCh2YWx1ZSkpIHx8ICghdmFsdWUgJiYgcmVxdWlyZWQpKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246ZW1haWxBZGRyZXNzJylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCB0ZXh0YXJlYTogVmFsaWRhdGU8dW5rbm93biwgdW5rbm93biwgVGV4dGFyZWFGaWVsZD4gPSAoXG4gIHZhbHVlOiBzdHJpbmcsXG4gIHsgY29uZmlnLCBtYXhMZW5ndGg6IGZpZWxkTWF4TGVuZ3RoLCBtaW5MZW5ndGgsIHBheWxvYWQsIHJlcXVpcmVkLCB0IH0sXG4pID0+IHtcbiAgbGV0IG1heExlbmd0aDogbnVtYmVyXG5cbiAgaWYgKHR5cGVvZiBjb25maWc/LmRlZmF1bHRNYXhUZXh0TGVuZ3RoID09PSAnbnVtYmVyJykgbWF4TGVuZ3RoID0gY29uZmlnLmRlZmF1bHRNYXhUZXh0TGVuZ3RoXG4gIGlmICh0eXBlb2YgZmllbGRNYXhMZW5ndGggPT09ICdudW1iZXInKSBtYXhMZW5ndGggPSBmaWVsZE1heExlbmd0aFxuICBpZiAodmFsdWUgJiYgbWF4TGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnNob3J0ZXJUaGFuTWF4JywgeyBtYXhMZW5ndGggfSlcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiBtaW5MZW5ndGggJiYgdmFsdWUubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246bG9uZ2VyVGhhbk1pbicsIHsgbWluTGVuZ3RoIH0pXG4gIH1cblxuICBpZiAocmVxdWlyZWQgJiYgIXZhbHVlKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246cmVxdWlyZWQnKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGNvbnN0IGNvZGU6IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIENvZGVGaWVsZD4gPSAodmFsdWU6IHN0cmluZywgeyByZXF1aXJlZCwgdCB9KSA9PiB7XG4gIGlmIChyZXF1aXJlZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246cmVxdWlyZWQnKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGNvbnN0IGpzb246IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIEpTT05GaWVsZCAmIHsganNvbkVycm9yPzogc3RyaW5nIH0+ID0gYXN5bmMgKFxuICB2YWx1ZTogc3RyaW5nLFxuICB7IGpzb25FcnJvciwganNvblNjaGVtYSwgcmVxdWlyZWQsIHQgfSxcbikgPT4ge1xuICBpZiAocmVxdWlyZWQgJiYgIXZhbHVlKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246cmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKGpzb25FcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246aW52YWxpZElucHV0JylcbiAgfVxuXG4gIGNvbnN0IGlzTm90RW1wdHkgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGZldGNoU2NoZW1hID0gKHsgdXJpLCBzY2hlbWEgfSkgPT4ge1xuICAgIGlmICh1cmkgJiYgc2NoZW1hKSByZXR1cm4gc2NoZW1hXG4gICAgcmV0dXJuIGZldGNoKHVyaSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2snKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0pXG4gICAgICAudGhlbigoanNvbikgPT4ge1xuICAgICAgICBjb25zdCBqc29uU2NoZW1hU2FuaXRpemF0aW9ucyA9IHtcbiAgICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICAgICRpZDoganNvbi5pZCxcbiAgICAgICAgICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJyxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hU2FuaXRpemF0aW9ucylcbiAgICAgIH0pXG4gIH1cblxuICBpZiAoIWNhblVzZURPTSAmJiBqc29uU2NoZW1hICYmIGlzTm90RW1wdHkodmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGpzb25TY2hlbWEuc2NoZW1hID0gYXdhaXQgZmV0Y2hTY2hlbWEoanNvblNjaGVtYSlcbiAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBqc29uU2NoZW1hXG4gICAgICBjb25zdCBhanYgPSBuZXcgQWp2KClcblxuICAgICAgaWYgKCFhanYudmFsaWRhdGUoc2NoZW1hLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHQoYWp2LmVycm9yc1RleHQoKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHQoZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgY29uc3QgY2hlY2tib3g6IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIENoZWNrYm94RmllbGQ+ID0gKFxuICB2YWx1ZTogYm9vbGVhbixcbiAgeyByZXF1aXJlZCwgdCB9LFxuKSA9PiB7XG4gIGlmICgodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHx8IChyZXF1aXJlZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykpIHtcbiAgICByZXR1cm4gdCgndmFsaWRhdGlvbjp0cnVlT3JGYWxzZScpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgY29uc3QgZGF0ZTogVmFsaWRhdGU8dW5rbm93biwgdW5rbm93biwgRGF0ZUZpZWxkPiA9ICh2YWx1ZSwgeyByZXF1aXJlZCwgdCB9KSA9PiB7XG4gIGlmICh2YWx1ZSAmJiAhaXNOYU4oRGF0ZS5wYXJzZSh2YWx1ZS50b1N0cmluZygpKSkpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1saW5lICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOm5vdFZhbGlkRGF0ZScsIHsgdmFsdWUgfSlcbiAgfVxuXG4gIGlmIChyZXF1aXJlZCkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnJlcXVpcmVkJylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCByaWNoVGV4dDogVmFsaWRhdGU8b2JqZWN0LCB1bmtub3duLCBSaWNoVGV4dEZpZWxkLCBSaWNoVGV4dEZpZWxkPiA9IGFzeW5jIChcbiAgdmFsdWUsXG4gIG9wdGlvbnMsXG4pID0+IHtcbiAgY29uc3QgZWRpdG9yOiBSaWNoVGV4dEFkYXB0ZXIgPSBvcHRpb25zPy5lZGl0b3JcblxuICByZXR1cm4gYXdhaXQgZWRpdG9yLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKVxufVxuXG5jb25zdCB2YWxpZGF0ZUFycmF5TGVuZ3RoOiBhbnkgPSAoXG4gIHZhbHVlLFxuICBvcHRpb25zOiB7XG4gICAgbWF4Um93cz86IG51bWJlclxuICAgIG1pblJvd3M/OiBudW1iZXJcbiAgICByZXF1aXJlZD86IGJvb2xlYW5cbiAgICB0OiAoa2V5OiBzdHJpbmcsIG9wdGlvbnM/OiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IHN0cmluZyB9KSA9PiBzdHJpbmdcbiAgfSxcbikgPT4ge1xuICBjb25zdCB7IG1heFJvd3MsIG1pblJvd3MsIHJlcXVpcmVkLCB0IH0gPSBvcHRpb25zXG5cbiAgY29uc3QgYXJyYXlMZW5ndGggPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IDBcblxuICBpZiAoIXJlcXVpcmVkICYmIGFycmF5TGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZVxuXG4gIGlmIChtaW5Sb3dzICYmIGFycmF5TGVuZ3RoIDwgbWluUm93cykge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnJlcXVpcmVzQXRMZWFzdCcsIHsgY291bnQ6IG1pblJvd3MsIGxhYmVsOiB0KCdyb3dzJykgfSlcbiAgfVxuXG4gIGlmIChtYXhSb3dzICYmIGFycmF5TGVuZ3RoID4gbWF4Um93cykge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnJlcXVpcmVzTm9Nb3JlVGhhbicsIHsgY291bnQ6IG1heFJvd3MsIGxhYmVsOiB0KCdyb3dzJykgfSlcbiAgfVxuXG4gIGlmIChyZXF1aXJlZCAmJiAhYXJyYXlMZW5ndGgpIHtcbiAgICByZXR1cm4gdCgndmFsaWRhdGlvbjpyZXF1aXJlc0F0TGVhc3QnLCB7IGNvdW50OiAxLCBsYWJlbDogdCgncm93JykgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCBudW1iZXI6IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIE51bWJlckZpZWxkPiA9IChcbiAgdmFsdWU6IG51bWJlciB8IG51bWJlcltdLFxuICB7IGhhc01hbnksIG1heCwgbWF4Um93cywgbWluLCBtaW5Sb3dzLCByZXF1aXJlZCwgdCB9LFxuKSA9PiB7XG4gIGlmIChoYXNNYW55ID09PSB0cnVlKSB7XG4gICAgY29uc3QgbGVuZ3RoVmFsaWRhdGlvblJlc3VsdCA9IHZhbGlkYXRlQXJyYXlMZW5ndGgodmFsdWUsIHsgbWF4Um93cywgbWluUm93cywgcmVxdWlyZWQsIHQgfSlcbiAgICBpZiAodHlwZW9mIGxlbmd0aFZhbGlkYXRpb25SZXN1bHQgPT09ICdzdHJpbmcnKSByZXR1cm4gbGVuZ3RoVmFsaWRhdGlvblJlc3VsdFxuICB9XG5cbiAgaWYgKCF2YWx1ZSAmJiAhaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgLy8gaWYgbm8gdmFsdWUgaXMgcHJlc2VudCwgdmFsaWRhdGUgYmFzZWQgb24gcmVxdWlyZWRcbiAgICBpZiAocmVxdWlyZWQpIHJldHVybiB0KCd2YWxpZGF0aW9uOnJlcXVpcmVkJylcbiAgICBpZiAoIXJlcXVpcmVkKSByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgbnVtYmVyc1RvVmFsaWRhdGU6IG51bWJlcltdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV1cblxuICBmb3IgKGNvbnN0IG51bWJlciBvZiBudW1iZXJzVG9WYWxpZGF0ZSkge1xuICAgIGlmICghaXNOdW1iZXIobnVtYmVyKSkgcmV0dXJuIHQoJ3ZhbGlkYXRpb246ZW50ZXJOdW1iZXInKVxuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUZsb2F0KG51bWJlciBhcyB1bmtub3duIGFzIHN0cmluZylcblxuICAgIGlmICh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJyAmJiBudW1iZXJWYWx1ZSA+IG1heCkge1xuICAgICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246Z3JlYXRlclRoYW5NYXgnLCB7IGxhYmVsOiB0KCd2YWx1ZScpLCBtYXgsIHZhbHVlIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtaW4gPT09ICdudW1iZXInICYmIG51bWJlclZhbHVlIDwgbWluKSB7XG4gICAgICByZXR1cm4gdCgndmFsaWRhdGlvbjpsZXNzVGhhbk1pbicsIHsgbGFiZWw6IHQoJ3ZhbHVlJyksIG1pbiwgdmFsdWUgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgY29uc3QgYXJyYXk6IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIEFycmF5RmllbGQ+ID0gKFxuICB2YWx1ZSxcbiAgeyBtYXhSb3dzLCBtaW5Sb3dzLCByZXF1aXJlZCwgdCB9LFxuKSA9PiB7XG4gIHJldHVybiB2YWxpZGF0ZUFycmF5TGVuZ3RoKHZhbHVlLCB7IG1heFJvd3MsIG1pblJvd3MsIHJlcXVpcmVkLCB0IH0pXG59XG5cbmV4cG9ydCBjb25zdCBibG9ja3M6IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIEJsb2NrRmllbGQ+ID0gKFxuICB2YWx1ZSxcbiAgeyBtYXhSb3dzLCBtaW5Sb3dzLCByZXF1aXJlZCwgdCB9LFxuKSA9PiB7XG4gIHJldHVybiB2YWxpZGF0ZUFycmF5TGVuZ3RoKHZhbHVlLCB7IG1heFJvd3MsIG1pblJvd3MsIHJlcXVpcmVkLCB0IH0pXG59XG5cbmNvbnN0IHZhbGlkYXRlRmlsdGVyT3B0aW9uczogVmFsaWRhdGUgPSBhc3luYyAoXG4gIHZhbHVlLFxuICB7IGlkLCBkYXRhLCBmaWx0ZXJPcHRpb25zLCBwYXlsb2FkLCByZWxhdGlvblRvLCByZXEsIHNpYmxpbmdEYXRhLCB0LCB1c2VyIH0sXG4pID0+IHtcbiAgaWYgKCFjYW5Vc2VET00gJiYgdHlwZW9mIGZpbHRlck9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlKSB7XG4gICAgY29uc3Qgb3B0aW9uczoge1xuICAgICAgW2NvbGxlY3Rpb246IHN0cmluZ106IChudW1iZXIgfCBzdHJpbmcpW11cbiAgICB9ID0ge31cblxuICAgIGNvbnN0IGZhbHNlQ29sbGVjdGlvbnM6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCBjb2xsZWN0aW9ucyA9IHR5cGVvZiByZWxhdGlvblRvID09PSAnc3RyaW5nJyA/IFtyZWxhdGlvblRvXSA6IHJlbGF0aW9uVG9cbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBjb2xsZWN0aW9ucy5tYXAoYXN5bmMgKGNvbGxlY3Rpb24pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgb3B0aW9uRmlsdGVyID1cbiAgICAgICAgICAgIHR5cGVvZiBmaWx0ZXJPcHRpb25zID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgID8gYXdhaXQgZmlsdGVyT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICByZWxhdGlvblRvOiBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgc2libGluZ0RhdGEsXG4gICAgICAgICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogZmlsdGVyT3B0aW9uc1xuXG4gICAgICAgICAgaWYgKG9wdGlvbkZpbHRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb3B0aW9uRmlsdGVyID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZhbHVlSURzOiAobnVtYmVyIHwgc3RyaW5nKVtdID0gW11cblxuICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWw/LnZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhbHVlSURzLnB1c2godmFsLnZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdmFsdWVJRHMucHVzaCh2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmICh2YWx1ZUlEcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5kV2hlcmUgPSB7XG4gICAgICAgICAgICAgIGFuZDogW3sgaWQ6IHsgaW46IHZhbHVlSURzIH0gfV0sXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25GaWx0ZXIpIGZpbmRXaGVyZS5hbmQucHVzaChvcHRpb25GaWx0ZXIpXG5cbiAgICAgICAgICAgIGlmIChvcHRpb25GaWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGZhbHNlQ29sbGVjdGlvbnMucHVzaChvcHRpb25GaWx0ZXIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBheWxvYWQuZmluZCh7XG4gICAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAgICAgICBsaW1pdDogMCxcbiAgICAgICAgICAgICAgcGFnaW5hdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgd2hlcmU6IGZpbmRXaGVyZSxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIG9wdGlvbnNbY29sbGVjdGlvbl0gPSByZXN1bHQuZG9jcy5tYXAoKGRvYykgPT4gZG9jLmlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zW2NvbGxlY3Rpb25dID0gW11cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlcS5wYXlsb2FkLmxvZ2dlci5lcnJvcih7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBtc2c6IGBFcnJvciB2YWxpZGF0aW5nIGZpbHRlciBvcHRpb25zIGZvciBjb2xsZWN0aW9uICR7Y29sbGVjdGlvbn1gLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgb3B0aW9uc1tjb2xsZWN0aW9uXSA9IFtdXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIClcblxuICAgIGNvbnN0IGludmFsaWRSZWxhdGlvbnNoaXBzID0gdmFsdWVzLmZpbHRlcigodmFsKSA9PiB7XG4gICAgICBsZXQgY29sbGVjdGlvbjogc3RyaW5nXG4gICAgICBsZXQgcmVxdWVzdGVkSUQ6IG51bWJlciB8IHN0cmluZ1xuXG4gICAgICBpZiAodHlwZW9mIHJlbGF0aW9uVG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSByZWxhdGlvblRvXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVxdWVzdGVkSUQgPSB2YWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWxhdGlvblRvKSAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWw/LnJlbGF0aW9uVG8pIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbC5yZWxhdGlvblRvXG4gICAgICAgIHJlcXVlc3RlZElEID0gdmFsLnZhbHVlXG4gICAgICB9XG5cbiAgICAgIGlmIChmYWxzZUNvbGxlY3Rpb25zLmZpbmQoKHNsdWcpID0+IHJlbGF0aW9uVG8gPT09IHNsdWcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zW2NvbGxlY3Rpb25dLmluZGV4T2YocmVxdWVzdGVkSUQpID09PSAtMVxuICAgIH0pXG5cbiAgICBpZiAoaW52YWxpZFJlbGF0aW9uc2hpcHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGludmFsaWRSZWxhdGlvbnNoaXBzLnJlZHVjZSgoZXJyLCBpbnZhbGlkLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBgJHtlcnJ9ICR7SlNPTi5zdHJpbmdpZnkoaW52YWxpZCl9JHtcbiAgICAgICAgICBpbnZhbGlkUmVsYXRpb25zaGlwcy5sZW5ndGggPT09IGkgKyAxID8gJywnIDogJydcbiAgICAgICAgfSBgXG4gICAgICB9LCB0KCd2YWxpZGF0aW9uOmludmFsaWRTZWxlY3Rpb25zJykpIGFzIHN0cmluZ1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgY29uc3QgdXBsb2FkOiBWYWxpZGF0ZTx1bmtub3duLCB1bmtub3duLCBVcGxvYWRGaWVsZD4gPSAodmFsdWU6IHN0cmluZywgb3B0aW9ucykgPT4ge1xuICBpZiAoIXZhbHVlICYmIG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICByZXR1cm4gb3B0aW9ucy50KCd2YWxpZGF0aW9uOnJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghY2FuVXNlRE9NICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICBjb25zdCBpZEZpZWxkID0gb3B0aW9ucz8uY29uZmlnPy5jb2xsZWN0aW9uc1xuICAgICAgPy5maW5kKChjb2xsZWN0aW9uKSA9PiBjb2xsZWN0aW9uLnNsdWcgPT09IG9wdGlvbnMucmVsYXRpb25UbylcbiAgICAgID8uZmllbGRzPy5maW5kKChmaWVsZCkgPT4gZmllbGRBZmZlY3RzRGF0YShmaWVsZCkgJiYgZmllbGQubmFtZSA9PT0gJ2lkJylcblxuICAgIGNvbnN0IHR5cGUgPSBnZXRJRFR5cGUoaWRGaWVsZCwgb3B0aW9ucz8ucGF5bG9hZD8uZGI/LmRlZmF1bHRJRFR5cGUpXG5cbiAgICBpZiAoIWlzVmFsaWRJRCh2YWx1ZSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnQoJ3ZhbGlkYXRpb246dmFsaWRVcGxvYWRJRCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlRmlsdGVyT3B0aW9ucyh2YWx1ZSwgb3B0aW9ucylcbn1cblxuZXhwb3J0IGNvbnN0IHJlbGF0aW9uc2hpcDogVmFsaWRhdGU8dW5rbm93biwgdW5rbm93biwgUmVsYXRpb25zaGlwRmllbGQ+ID0gYXN5bmMgKFxuICB2YWx1ZTogUmVsYXRpb25zaGlwVmFsdWUsXG4gIG9wdGlvbnMsXG4pID0+IHtcbiAgY29uc3QgeyBjb25maWcsIG1heFJvd3MsIG1pblJvd3MsIHBheWxvYWQsIHJlbGF0aW9uVG8sIHJlcXVpcmVkLCB0IH0gPSBvcHRpb25zXG5cbiAgaWYgKCghdmFsdWUgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpICYmIHJlcXVpcmVkKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246cmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICBpZiAobWluUm93cyAmJiB2YWx1ZS5sZW5ndGggPCBtaW5Sb3dzKSB7XG4gICAgICByZXR1cm4gdCgndmFsaWRhdGlvbjpsZXNzVGhhbk1pbicsIHsgbGFiZWw6IHQoJ3Jvd3MnKSwgbWluOiBtaW5Sb3dzLCB2YWx1ZTogdmFsdWUubGVuZ3RoIH0pXG4gICAgfVxuXG4gICAgaWYgKG1heFJvd3MgJiYgdmFsdWUubGVuZ3RoID4gbWF4Um93cykge1xuICAgICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246Z3JlYXRlclRoYW5NYXgnLCB7IGxhYmVsOiB0KCdyb3dzJyksIG1heDogbWF4Um93cywgdmFsdWU6IHZhbHVlLmxlbmd0aCB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghY2FuVXNlRE9NICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXVxuXG4gICAgY29uc3QgaW52YWxpZFJlbGF0aW9uc2hpcHMgPSB2YWx1ZXMuZmlsdGVyKCh2YWwpID0+IHtcbiAgICAgIGxldCBjb2xsZWN0aW9uU2x1Zzogc3RyaW5nXG4gICAgICBsZXQgcmVxdWVzdGVkSURcblxuICAgICAgaWYgKHR5cGVvZiByZWxhdGlvblRvID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb2xsZWN0aW9uU2x1ZyA9IHJlbGF0aW9uVG9cblxuICAgICAgICAvLyBjdXN0b20gaWRcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIHJlcXVlc3RlZElEID0gdmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVsYXRpb25UbykgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsPy5yZWxhdGlvblRvKSB7XG4gICAgICAgIGNvbGxlY3Rpb25TbHVnID0gdmFsLnJlbGF0aW9uVG9cbiAgICAgICAgcmVxdWVzdGVkSUQgPSB2YWwudmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3RlZElEID09PSBudWxsKSByZXR1cm4gZmFsc2VcblxuICAgICAgY29uc3QgaWRGaWVsZCA9IGNvbmZpZz8uY29sbGVjdGlvbnNcbiAgICAgICAgPy5maW5kKChjb2xsZWN0aW9uKSA9PiBjb2xsZWN0aW9uLnNsdWcgPT09IGNvbGxlY3Rpb25TbHVnKVxuICAgICAgICA/LmZpZWxkcz8uZmluZCgoZmllbGQpID0+IGZpZWxkQWZmZWN0c0RhdGEoZmllbGQpICYmIGZpZWxkLm5hbWUgPT09ICdpZCcpXG5cbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRJRFR5cGUoaWRGaWVsZCwgcGF5bG9hZD8uZGI/LmRlZmF1bHRJRFR5cGUpXG5cbiAgICAgIHJldHVybiAhaXNWYWxpZElEKHJlcXVlc3RlZElELCB0eXBlKVxuICAgIH0pXG5cbiAgICBpZiAoaW52YWxpZFJlbGF0aW9uc2hpcHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGBUaGlzIHJlbGF0aW9uc2hpcCBmaWVsZCBoYXMgdGhlIGZvbGxvd2luZyBpbnZhbGlkIHJlbGF0aW9uc2hpcHM6ICR7aW52YWxpZFJlbGF0aW9uc2hpcHNcbiAgICAgICAgLm1hcCgoZXJyLCBpbnZhbGlkKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGAke2Vycn0gJHtKU09OLnN0cmluZ2lmeShpbnZhbGlkKX1gXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpfWBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVGaWx0ZXJPcHRpb25zKHZhbHVlLCBvcHRpb25zKVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0OiBWYWxpZGF0ZTx1bmtub3duLCB1bmtub3duLCBTZWxlY3RGaWVsZD4gPSAoXG4gIHZhbHVlLFxuICB7IGhhc01hbnksIG9wdGlvbnMsIHJlcXVpcmVkLCB0IH0sXG4pID0+IHtcbiAgaWYgKFxuICAgIEFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgdmFsdWUuc29tZShcbiAgICAgIChpbnB1dCkgPT5cbiAgICAgICAgIW9wdGlvbnMuc29tZShcbiAgICAgICAgICAob3B0aW9uKSA9PiBvcHRpb24gPT09IGlucHV0IHx8ICh0eXBlb2Ygb3B0aW9uICE9PSAnc3RyaW5nJyAmJiBvcHRpb24/LnZhbHVlID09PSBpbnB1dCksXG4gICAgICAgICksXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdCgndmFsaWRhdGlvbjppbnZhbGlkU2VsZWN0aW9uJylcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgIW9wdGlvbnMuc29tZShcbiAgICAgIChvcHRpb24pID0+IG9wdGlvbiA9PT0gdmFsdWUgfHwgKHR5cGVvZiBvcHRpb24gIT09ICdzdHJpbmcnICYmIG9wdGlvbi52YWx1ZSA9PT0gdmFsdWUpLFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHQoJ3ZhbGlkYXRpb246aW52YWxpZFNlbGVjdGlvbicpXG4gIH1cblxuICBpZiAoXG4gICAgcmVxdWlyZWQgJiZcbiAgICAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgdmFsdWUgPT09IG51bGwgfHxcbiAgICAgIChoYXNNYW55ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZSBhcyBbXSk/Lmxlbmd0aCA9PT0gMCkpXG4gICkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOnJlcXVpcmVkJylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCByYWRpbzogVmFsaWRhdGU8dW5rbm93biwgdW5rbm93biwgUmFkaW9GaWVsZD4gPSAodmFsdWUsIHsgb3B0aW9ucywgcmVxdWlyZWQsIHQgfSkgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZU1hdGNoZXNPcHRpb24gPSBvcHRpb25zLnNvbWUoXG4gICAgICAob3B0aW9uKSA9PiBvcHRpb24gPT09IHZhbHVlIHx8ICh0eXBlb2Ygb3B0aW9uICE9PSAnc3RyaW5nJyAmJiBvcHRpb24udmFsdWUgPT09IHZhbHVlKSxcbiAgICApXG4gICAgcmV0dXJuIHZhbHVlTWF0Y2hlc09wdGlvbiB8fCB0KCd2YWxpZGF0aW9uOmludmFsaWRTZWxlY3Rpb24nKVxuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVkID8gdCgndmFsaWRhdGlvbjpyZXF1aXJlZCcpIDogdHJ1ZVxufVxuXG5leHBvcnQgY29uc3QgcG9pbnQ6IFZhbGlkYXRlPHVua25vd24sIHVua25vd24sIFBvaW50RmllbGQ+ID0gKFxuICB2YWx1ZTogW251bWJlciB8IHN0cmluZywgbnVtYmVyIHwgc3RyaW5nXSA9IFsnJywgJyddLFxuICB7IHJlcXVpcmVkLCB0IH0sXG4pID0+IHtcbiAgY29uc3QgbG5nID0gcGFyc2VGbG9hdChTdHJpbmcodmFsdWVbMF0pKVxuICBjb25zdCBsYXQgPSBwYXJzZUZsb2F0KFN0cmluZyh2YWx1ZVsxXSkpXG4gIGlmIChcbiAgICByZXF1aXJlZCAmJlxuICAgICgodmFsdWVbMF0gJiYgdmFsdWVbMV0gJiYgdHlwZW9mIGxuZyAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhdCAhPT0gJ251bWJlcicpIHx8XG4gICAgICBOdW1iZXIuaXNOYU4obG5nKSB8fFxuICAgICAgTnVtYmVyLmlzTmFOKGxhdCkgfHxcbiAgICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggIT09IDIpKVxuICApIHtcbiAgICByZXR1cm4gdCgndmFsaWRhdGlvbjpyZXF1aXJlc1R3b051bWJlcnMnKVxuICB9XG5cbiAgaWYgKCh2YWx1ZVsxXSAmJiBOdW1iZXIuaXNOYU4obG5nKSkgfHwgKHZhbHVlWzBdICYmIE51bWJlci5pc05hTihsYXQpKSkge1xuICAgIHJldHVybiB0KCd2YWxpZGF0aW9uOmludmFsaWRJbnB1dCcpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFycmF5LFxuICBibG9ja3MsXG4gIGNoZWNrYm94LFxuICBjb2RlLFxuICBkYXRlLFxuICBlbWFpbCxcbiAganNvbixcbiAgbnVtYmVyLFxuICBwYXNzd29yZCxcbiAgcG9pbnQsXG4gIHJhZGlvLFxuICByZWxhdGlvbnNoaXAsXG4gIHJpY2hUZXh0LFxuICBzZWxlY3QsXG4gIHRleHQsXG4gIHRleHRhcmVhLFxuICB1cGxvYWQsXG59XG4iXSwibmFtZXMiOlsiYXJyYXkiLCJibG9ja3MiLCJjaGVja2JveCIsImNvZGUiLCJkYXRlIiwiZW1haWwiLCJqc29uIiwibnVtYmVyIiwicGFzc3dvcmQiLCJwb2ludCIsInJhZGlvIiwicmVsYXRpb25zaGlwIiwicmljaFRleHQiLCJzZWxlY3QiLCJ0ZXh0IiwidGV4dGFyZWEiLCJ1cGxvYWQiLCJ2YWx1ZSIsImNvbmZpZyIsImhhc01hbnkiLCJtYXhMZW5ndGgiLCJmaWVsZE1heExlbmd0aCIsIm1heFJvd3MiLCJtaW5MZW5ndGgiLCJtaW5Sb3dzIiwicmVxdWlyZWQiLCJ0IiwibGVuZ3RoVmFsaWRhdGlvblJlc3VsdCIsInZhbGlkYXRlQXJyYXlMZW5ndGgiLCJkZWZhdWx0TWF4VGV4dExlbmd0aCIsInN0cmluZ3NUb1ZhbGlkYXRlIiwiQXJyYXkiLCJpc0FycmF5Iiwic3RyaW5nVmFsdWUiLCJsZW5ndGgiLCJsYWJlbCIsInBheWxvYWQiLCJ0ZXN0IiwidW5kZWZpbmVkIiwianNvbkVycm9yIiwianNvblNjaGVtYSIsImlzTm90RW1wdHkiLCJPYmplY3QiLCJrZXlzIiwiZmV0Y2hTY2hlbWEiLCJ1cmkiLCJzY2hlbWEiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsIm9rIiwiRXJyb3IiLCJqc29uU2NoZW1hU2FuaXRpemF0aW9ucyIsImlkIiwiJGlkIiwiJHNjaGVtYSIsImFzc2lnbiIsImNhblVzZURPTSIsImFqdiIsIkFqdiIsInZhbGlkYXRlIiwiZXJyb3JzVGV4dCIsImVycm9yIiwibWVzc2FnZSIsImlzTmFOIiwiRGF0ZSIsInBhcnNlIiwidG9TdHJpbmciLCJvcHRpb25zIiwiZWRpdG9yIiwiYXJyYXlMZW5ndGgiLCJjb3VudCIsIm1heCIsIm1pbiIsImlzTnVtYmVyIiwibnVtYmVyc1RvVmFsaWRhdGUiLCJudW1iZXJWYWx1ZSIsInBhcnNlRmxvYXQiLCJ2YWxpZGF0ZUZpbHRlck9wdGlvbnMiLCJkYXRhIiwiZmlsdGVyT3B0aW9ucyIsInJlbGF0aW9uVG8iLCJyZXEiLCJzaWJsaW5nRGF0YSIsInVzZXIiLCJmYWxzZUNvbGxlY3Rpb25zIiwiY29sbGVjdGlvbnMiLCJ2YWx1ZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiY29sbGVjdGlvbiIsIm9wdGlvbkZpbHRlciIsInZhbHVlSURzIiwiZm9yRWFjaCIsInZhbCIsInB1c2giLCJmaW5kV2hlcmUiLCJhbmQiLCJpbiIsInJlc3VsdCIsImZpbmQiLCJkZXB0aCIsImxpbWl0IiwicGFnaW5hdGlvbiIsIndoZXJlIiwiZG9jcyIsImRvYyIsImVyciIsImxvZ2dlciIsIm1zZyIsImludmFsaWRSZWxhdGlvbnNoaXBzIiwiZmlsdGVyIiwicmVxdWVzdGVkSUQiLCJzbHVnIiwiaW5kZXhPZiIsInJlZHVjZSIsImludmFsaWQiLCJpIiwiSlNPTiIsInN0cmluZ2lmeSIsImlkRmllbGQiLCJmaWVsZHMiLCJmaWVsZCIsImZpZWxkQWZmZWN0c0RhdGEiLCJuYW1lIiwidHlwZSIsImdldElEVHlwZSIsImRiIiwiZGVmYXVsdElEVHlwZSIsImlzVmFsaWRJRCIsImNvbGxlY3Rpb25TbHVnIiwiam9pbiIsInNvbWUiLCJpbnB1dCIsIm9wdGlvbiIsInZhbHVlTWF0Y2hlc09wdGlvbiIsImxuZyIsIlN0cmluZyIsImxhdCIsIk51bWJlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUEwU2FBLEtBQUs7ZUFBTEE7O0lBT0FDLE1BQU07ZUFBTkE7O0lBNUdBQyxRQUFRO2VBQVJBOztJQXhFQUMsSUFBSTtlQUFKQTs7SUFtRkFDLElBQUk7ZUFBSkE7O0lBc1hiLE9Ba0JDO2VBbEJEOztJQXhlYUMsS0FBSztlQUFMQTs7SUF1Q0FDLElBQUk7ZUFBSkE7O0lBbUlBQyxNQUFNO2VBQU5BOztJQWxNQUMsUUFBUTtlQUFSQTs7SUF5ZUFDLEtBQUs7ZUFBTEE7O0lBWEFDLEtBQUs7ZUFBTEE7O0lBckdBQyxZQUFZO2VBQVpBOztJQTlOQUMsUUFBUTtlQUFSQTs7SUE4UkFDLE1BQU07ZUFBTkE7O0lBbGVBQyxJQUFJO2VBQUpBOztJQXlFQUMsUUFBUTtlQUFSQTs7SUFxVUFDLE1BQU07ZUFBTkE7Ozs0REEzYUc7a0VBdUJNOzJCQUNJOzBCQUNEOzJCQUNDO3VCQUNPOzs7Ozs7QUFFMUIsTUFBTUYsT0FBOEMsQ0FDekRHLE9BQ0EsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFdBQVdDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxDQUFDLEVBQUU7SUFFeEYsSUFBSU47SUFFSixJQUFJLENBQUNLLFVBQVU7UUFDYixJQUFJLENBQUNSLE9BQU8sT0FBTztJQUNyQjtJQUVBLElBQUlFLFlBQVksTUFBTTtRQUNwQixNQUFNUSx5QkFBeUJDLG9CQUFvQlgsT0FBTztZQUFFSztZQUFTRTtZ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