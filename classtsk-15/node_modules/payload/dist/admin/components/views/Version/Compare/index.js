"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _qs = /*#__PURE__*/ _interop_require_default(require("qs"));
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _formatDate = require("../../../../utilities/formatDate");
const _ReactSelect = /*#__PURE__*/ _interop_require_default(require("../../../elements/ReactSelect"));
const _shared = require("../../../forms/field-types/shared");
const _Config = require("../../../utilities/Config");
const _shared1 = require("../shared");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'compare-version';
const maxResultsPerRequest = 10;
const baseOptions = [
    _shared1.mostRecentVersionOption
];
const CompareVersion = (props)=>{
    const { baseURL, onChange, parentID, publishedDoc, value, versionID } = props;
    const { admin: { dateFormat } } = (0, _Config.useConfig)();
    const [options, setOptions] = (0, _react.useState)(baseOptions);
    const [lastLoadedPage, setLastLoadedPage] = (0, _react.useState)(1);
    const [errorLoading, setErrorLoading] = (0, _react.useState)('');
    const { i18n, t } = (0, _reacti18next.useTranslation)('version');
    const getResults = (0, _react.useCallback)(async ({ lastLoadedPage: lastLoadedPageArg })=>{
        const query = {
            depth: 0,
            limit: maxResultsPerRequest,
            page: lastLoadedPageArg,
            where: {
                and: [
                    {
                        id: {
                            not_equals: versionID
                        }
                    }
                ]
            }
        };
        if (parentID) {
            query.where.and.push({
                parent: {
                    equals: parentID
                }
            });
        }
        const search = _qs.default.stringify(query);
        const response = await fetch(`${baseURL}?${search}`, {
            credentials: 'include',
            headers: {
                'Accept-Language': i18n.language
            }
        });
        if (response.ok) {
            const data = await response.json();
            if (data.docs.length > 0) {
                setOptions((existingOptions)=>[
                        ...existingOptions,
                        ...data.docs.map((doc)=>({
                                label: (0, _formatDate.formatDate)(doc.updatedAt, dateFormat, i18n?.language),
                                value: doc.id
                            }))
                    ]);
                setLastLoadedPage(data.page);
            }
        } else {
            setErrorLoading(t('error:unspecific'));
        }
    }, [
        dateFormat,
        baseURL,
        parentID,
        versionID,
        t,
        i18n
    ]);
    (0, _react.useEffect)(()=>{
        getResults({
            lastLoadedPage: 1
        });
    }, [
        getResults
    ]);
    (0, _react.useEffect)(()=>{
        if (publishedDoc?._status === 'published') setOptions((currentOptions)=>[
                _shared1.publishedVersionOption,
                ...currentOptions
            ]);
    }, [
        publishedDoc
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            _shared.fieldBaseClass,
            baseClass,
            errorLoading && 'error-loading'
        ].filter(Boolean).join(' ')
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__label`
    }, t('compareVersion')), !errorLoading && /*#__PURE__*/ _react.default.createElement(_ReactSelect.default, {
        isClearable: false,
        isSearchable: false,
        onChange: onChange,
        onMenuScrollToBottom: ()=>{
            getResults({
                lastLoadedPage: lastLoadedPage + 1
            });
        },
        options: options,
        placeholder: t('selectVersionToCompare'),
        value: value
    }), errorLoading && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__error-loading`
    }, errorLoading));
};
const _default = CompareVersion;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL3ZpZXdzL1ZlcnNpb24vQ29tcGFyZS9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHFzIGZyb20gJ3FzJ1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgUGFnaW5hdGVkRG9jcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2RhdGFiYXNlL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBXaGVyZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IGZvcm1hdERhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvZm9ybWF0RGF0ZSdcbmltcG9ydCBSZWFjdFNlbGVjdCBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9SZWFjdFNlbGVjdCdcbmltcG9ydCB7IGZpZWxkQmFzZUNsYXNzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybXMvZmllbGQtdHlwZXMvc2hhcmVkJ1xuaW1wb3J0IHsgdXNlQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL0NvbmZpZydcbmltcG9ydCB7IG1vc3RSZWNlbnRWZXJzaW9uT3B0aW9uLCBwdWJsaXNoZWRWZXJzaW9uT3B0aW9uIH0gZnJvbSAnLi4vc2hhcmVkJ1xuaW1wb3J0ICcuL2luZGV4LnNjc3MnXG5cbmNvbnN0IGJhc2VDbGFzcyA9ICdjb21wYXJlLXZlcnNpb24nXG5cbmNvbnN0IG1heFJlc3VsdHNQZXJSZXF1ZXN0ID0gMTBcblxuY29uc3QgYmFzZU9wdGlvbnMgPSBbbW9zdFJlY2VudFZlcnNpb25PcHRpb25dXG5cbmNvbnN0IENvbXBhcmVWZXJzaW9uOiBSZWFjdC5GQzxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBiYXNlVVJMLCBvbkNoYW5nZSwgcGFyZW50SUQsIHB1Ymxpc2hlZERvYywgdmFsdWUsIHZlcnNpb25JRCB9ID0gcHJvcHNcblxuICBjb25zdCB7XG4gICAgYWRtaW46IHsgZGF0ZUZvcm1hdCB9LFxuICB9ID0gdXNlQ29uZmlnKClcblxuICBjb25zdCBbb3B0aW9ucywgc2V0T3B0aW9uc10gPSB1c2VTdGF0ZShiYXNlT3B0aW9ucylcbiAgY29uc3QgW2xhc3RMb2FkZWRQYWdlLCBzZXRMYXN0TG9hZGVkUGFnZV0gPSB1c2VTdGF0ZSgxKVxuICBjb25zdCBbZXJyb3JMb2FkaW5nLCBzZXRFcnJvckxvYWRpbmddID0gdXNlU3RhdGUoJycpXG4gIGNvbnN0IHsgaTE4biwgdCB9ID0gdXNlVHJhbnNsYXRpb24oJ3ZlcnNpb24nKVxuXG4gIGNvbnN0IGdldFJlc3VsdHMgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoeyBsYXN0TG9hZGVkUGFnZTogbGFzdExvYWRlZFBhZ2VBcmcgfSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnk6IHtcbiAgICAgICAgW2tleTogc3RyaW5nXTogdW5rbm93blxuICAgICAgICB3aGVyZTogV2hlcmVcbiAgICAgIH0gPSB7XG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICBsaW1pdDogbWF4UmVzdWx0c1BlclJlcXVlc3QsXG4gICAgICAgIHBhZ2U6IGxhc3RMb2FkZWRQYWdlQXJnLFxuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGFuZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIG5vdF9lcXVhbHM6IHZlcnNpb25JRCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudElEKSB7XG4gICAgICAgIHF1ZXJ5LndoZXJlLmFuZC5wdXNoKHtcbiAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgIGVxdWFsczogcGFyZW50SUQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VhcmNoID0gcXMuc3RyaW5naWZ5KHF1ZXJ5KVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfT8ke3NlYXJjaH1gLCB7XG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBkYXRhOiBQYWdpbmF0ZWREb2NzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgIGlmIChkYXRhLmRvY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldE9wdGlvbnMoKGV4aXN0aW5nT3B0aW9ucykgPT4gW1xuICAgICAgICAgICAgLi4uZXhpc3RpbmdPcHRpb25zLFxuICAgICAgICAgICAgLi4uZGF0YS5kb2NzLm1hcCgoZG9jKSA9PiAoe1xuICAgICAgICAgICAgICBsYWJlbDogZm9ybWF0RGF0ZShkb2MudXBkYXRlZEF0LCBkYXRlRm9ybWF0LCBpMThuPy5sYW5ndWFnZSksXG4gICAgICAgICAgICAgIHZhbHVlOiBkb2MuaWQsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgXSlcbiAgICAgICAgICBzZXRMYXN0TG9hZGVkUGFnZShkYXRhLnBhZ2UpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yTG9hZGluZyh0KCdlcnJvcjp1bnNwZWNpZmljJykpXG4gICAgICB9XG4gICAgfSxcbiAgICBbZGF0ZUZvcm1hdCwgYmFzZVVSTCwgcGFyZW50SUQsIHZlcnNpb25JRCwgdCwgaTE4bl0sXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGdldFJlc3VsdHMoeyBsYXN0TG9hZGVkUGFnZTogMSB9KVxuICB9LCBbZ2V0UmVzdWx0c10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHVibGlzaGVkRG9jPy5fc3RhdHVzID09PSAncHVibGlzaGVkJylcbiAgICAgIHNldE9wdGlvbnMoKGN1cnJlbnRPcHRpb25zKSA9PiBbcHVibGlzaGVkVmVyc2lvbk9wdGlvbiwgLi4uY3VycmVudE9wdGlvbnNdKVxuICB9LCBbcHVibGlzaGVkRG9jXSlcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17W2ZpZWxkQmFzZUNsYXNzLCBiYXNlQ2xhc3MsIGVycm9yTG9hZGluZyAmJiAnZXJyb3ItbG9hZGluZyddXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fbGFiZWxgfT57dCgnY29tcGFyZVZlcnNpb24nKX08L2Rpdj5cbiAgICAgIHshZXJyb3JMb2FkaW5nICYmIChcbiAgICAgICAgPFJlYWN0U2VsZWN0XG4gICAgICAgICAgaXNDbGVhcmFibGU9e2ZhbHNlfVxuICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgIG9uTWVudVNjcm9sbFRvQm90dG9tPXsoKSA9PiB7XG4gICAgICAgICAgICBnZXRSZXN1bHRzKHsgbGFzdExvYWRlZFBhZ2U6IGxhc3RMb2FkZWRQYWdlICsgMSB9KVxuICAgICAgICAgIH19XG4gICAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgICAgICBwbGFjZWhvbGRlcj17dCgnc2VsZWN0VmVyc2lvblRvQ29tcGFyZScpfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7ZXJyb3JMb2FkaW5nICYmIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19lcnJvci1sb2FkaW5nYH0+e2Vycm9yTG9hZGluZ308L2Rpdj59XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcGFyZVZlcnNpb25cbiJdLCJuYW1lcyI6WyJiYXNlQ2xhc3MiLCJtYXhSZXN1bHRzUGVyUmVxdWVzdCIsImJhc2VPcHRpb25zIiwibW9zdFJlY2VudFZlcnNpb25PcHRpb24iLCJDb21wYXJlVmVyc2lvbiIsInByb3BzIiwiYmFzZVVSTCIsIm9uQ2hhbmdlIiwicGFyZW50SUQiLCJwdWJsaXNoZWREb2MiLCJ2YWx1ZSIsInZlcnNpb25JRCIsImFkbWluIiwiZGF0ZUZvcm1hdCIsInVzZUNvbmZpZyIsIm9wdGlvbnMiLCJzZXRPcHRpb25zIiwidXNlU3RhdGUiLCJsYXN0TG9hZGVkUGFnZSIsInNldExhc3RMb2FkZWRQYWdlIiwiZXJyb3JMb2FkaW5nIiwic2V0RXJyb3JMb2FkaW5nIiwiaTE4biIsInQiLCJ1c2VUcmFuc2xhdGlvbiIsImdldFJlc3VsdHMiLCJ1c2VDYWxsYmFjayIsImxhc3RMb2FkZWRQYWdlQXJnIiwicXVlcnkiLCJkZXB0aCIsImxpbWl0IiwicGFnZSIsIndoZXJlIiwiYW5kIiwiaWQiLCJub3RfZXF1YWxzIiwicHVzaCIsInBhcmVudCIsImVxdWFscyIsInNlYXJjaCIsInFzIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImxhbmd1YWdlIiwib2siLCJkYXRhIiwianNvbiIsImRvY3MiLCJsZW5ndGgiLCJleGlzdGluZ09wdGlvbnMiLCJtYXAiLCJkb2MiLCJsYWJlbCIsImZvcm1hdERhdGUiLCJ1cGRhdGVkQXQiLCJ1c2VFZmZlY3QiLCJfc3RhdHVzIiwiY3VycmVudE9wdGlvbnMiLCJwdWJsaXNoZWRWZXJzaW9uT3B0aW9uIiwiZGl2IiwiY2xhc3NOYW1lIiwiZmllbGRCYXNlQ2xhc3MiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIlJlYWN0U2VsZWN0IiwiaXNDbGVhcmFibGUiLCJpc1NlYXJjaGFibGUiLCJvbk1lbnVTY3JvbGxUb0JvdHRvbSIsInBsYWNlaG9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7OytCQTBIQTs7O2VBQUE7OzsyREExSGU7K0RBQ3lDOzhCQUN6Qjs0QkFNSjtvRUFDSDt3QkFDTzt3QkFDTDt5QkFDc0M7UUFDekQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRVAsTUFBTUEsWUFBWTtBQUVsQixNQUFNQyx1QkFBdUI7QUFFN0IsTUFBTUMsY0FBYztJQUFDQyxnQ0FBdUI7Q0FBQztBQUU3QyxNQUFNQyxpQkFBa0MsQ0FBQ0M7SUFDdkMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFLEdBQUdOO0lBRXhFLE1BQU0sRUFDSk8sT0FBTyxFQUFFQyxVQUFVLEVBQUUsRUFDdEIsR0FBR0MsSUFBQUEsaUJBQVM7SUFFYixNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR0MsSUFBQUEsZUFBUSxFQUFDZjtJQUN2QyxNQUFNLENBQUNnQixnQkFBZ0JDLGtCQUFrQixHQUFHRixJQUFBQSxlQUFRLEVBQUM7SUFDckQsTUFBTSxDQUFDRyxjQUFjQyxnQkFBZ0IsR0FBR0osSUFBQUEsZUFBUSxFQUFDO0lBQ2pELE1BQU0sRUFBRUssSUFBSSxFQUFFQyxDQUFDLEVBQUUsR0FBR0MsSUFBQUEsNEJBQWMsRUFBQztJQUVuQyxNQUFNQyxhQUFhQyxJQUFBQSxrQkFBVyxFQUM1QixPQUFPLEVBQUVSLGdCQUFnQlMsaUJBQWlCLEVBQUU7UUFDMUMsTUFBTUMsUUFHRjtZQUNGQyxPQUFPO1lBQ1BDLE9BQU83QjtZQUNQOEIsTUFBTUo7WUFDTkssT0FBTztnQkFDTEMsS0FBSztvQkFDSDt3QkFDRUMsSUFBSTs0QkFDRkMsWUFBWXhCO3dCQUNkO29CQUNGO2lCQUNEO1lBQ0g7UUFDRjtRQUVBLElBQUlILFVBQVU7WUFDWm9CLE1BQU1JLEtBQUssQ0FBQ0MsR0FBRyxDQUFDRyxJQUFJLENBQUM7Z0JBQ25CQyxRQUFRO29CQUNOQyxRQUFROUI7Z0JBQ1Y7WUFDRjtRQUNGO1FBRUEsTUFBTStCLFNBQVNDLFdBQUUsQ0FBQ0MsU0FBUyxDQUFDYjtRQUM1QixNQUFNYyxXQUFXLE1BQU1DLE1BQU0sQ0FBQyxFQUFFckMsUUFBUSxDQUFDLEVBQUVpQyxPQUFPLENBQUMsRUFBRTtZQUNuREssYUFBYTtZQUNiQyxTQUFTO2dCQUNQLG1CQUFtQnZCLEtBQUt3QixRQUFRO1lBQ2xDO1FBQ0Y7UUFFQSxJQUFJSixTQUFTSyxFQUFFLEVBQUU7WUFDZixNQUFNQyxPQUFzQixNQUFNTixTQUFTTyxJQUFJO1lBQy9DLElBQUlELEtBQUtFLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCbkMsV0FBVyxDQUFDb0Msa0JBQW9COzJCQUMzQkE7MkJBQ0FKLEtBQUtFLElBQUksQ0FBQ0csR0FBRyxDQUFDLENBQUNDLE1BQVMsQ0FBQTtnQ0FDekJDLE9BQU9DLElBQUFBLHNCQUFVLEVBQUNGLElBQUlHLFNBQVMsRUFBRTVDLFlBQVlTLE1BQU13QjtnQ0FDbkRwQyxPQUFPNEMsSUFBSXBCLEVBQUU7NEJBQ2YsQ0FBQTtxQkFDRDtnQkFDRGYsa0JBQWtCNkIsS0FBS2pCLElBQUk7WUFDN0I7UUFDRixPQUFPO1lBQ0xWLGdCQUFnQkUsRUFBRTtRQUNwQjtJQUNGLEdBQ0E7UUFBQ1Y7UUFBWVA7UUFBU0U7UUFBVUc7UUFBV1k7UUFBR0Q7S0FBSztJQUdyRG9DLElBQUFBLGdCQUFTLEVBQUM7UUFDUmpDLFdBQVc7WUFBRVAsZ0JBQWdCO1FBQUU7SUFDakMsR0FBRztRQUFDTztLQUFXO0lBRWZpQyxJQUFBQSxnQkFBUyxFQUFDO1FBQ1IsSUFBSWpELGNBQWNrRCxZQUFZLGFBQzVCM0MsV0FBVyxDQUFDNEMsaUJBQW1CO2dCQUFDQywrQkFBc0I7bUJBQUtEO2FBQWU7SUFDOUUsR0FBRztRQUFDbkQ7S0FBYTtJQUVqQixxQkFDRSw2QkFBQ3FEO1FBQ0NDLFdBQVc7WUFBQ0Msc0JBQWM7WUFBRWhFO1lBQVdvQixnQkFBZ0I7U0FBZ0IsQ0FDcEU2QyxNQUFNLENBQUNDLFNBQ1BDLElBQUksQ0FBQztxQkFFUiw2QkFBQ0w7UUFBSUMsV0FBVyxDQUFDLEVBQUUvRCxVQUFVLE9BQU8sQ0FBQztPQUFHdUIsRUFBRSxvQkFDekMsQ0FBQ0gsOEJBQ0EsNkJBQUNnRCxvQkFBVztRQUNWQyxhQUFhO1FBQ2JDLGNBQWM7UUFDZC9ELFVBQVVBO1FBQ1ZnRSxzQkFBc0I7WUFDcEI5QyxXQUFXO2dCQUFFUCxnQkFBZ0JBLGlCQUFpQjtZQUFFO1FBQ2xEO1FBQ0FILFNBQVNBO1FBQ1R5RCxhQUFhakQsRUFBRTtRQUNmYixPQUFPQTtRQUdWVSw4QkFBZ0IsNkJBQUMwQztRQUFJQyxXQUFXLENBQUMsRUFBRS9ELFVBQVUsZUFBZSxDQUFDO09BQUdvQjtBQUd2RTtNQUVBLFdBQWVoQiJ9